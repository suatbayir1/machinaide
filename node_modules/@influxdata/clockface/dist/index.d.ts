/// <reference types="react" />
// Libraries
import React from "react";
import { CSSProperties, ReactNode, Component, MouseEvent, FunctionComponent, PureComponent, UIEvent, RefObject, ChangeEvent, KeyboardEvent } from "react";
import { ScrollState } from "react-scrollbars-custom/dist/types/types"; // Styles
// Styles
// Styles
// Styles
// Utilities
type Omit<K, V> = Pick<K, Exclude<keyof K, V>>; // Standardized prop definitons
// Standardized prop definitons
interface StandardFunctionProps {
    /** Unique identifier for getting an element */
    id?: string;
    /** Useful for setting common attributes like width or height */
    style?: CSSProperties;
    /** ID for Integration Tests */
    testID?: string;
    /** Children */
    children?: ReactNode;
    /** Useful for overriding styles of the component and its constituent elements */
    className?: string;
} // Standard Validation Function
// Standard Validation Function
type ValidationFunction = (input: string) => string | null; // Passing in link elements
// Passing in link elements
type RenderLinkElement = (className: string) => JSX.Element; // Shared Data Types
// Shared Data Types
declare enum ComponentColor {
    Default = "default",
    Primary = "primary",
    Secondary = "secondary",
    Tertiary = "tertiary",
    Success = "success",
    Warning = "warning",
    Danger = "danger"
}
declare enum ComponentSize {
    ExtraSmall = "xs",
    Small = "sm",
    Medium = "md",
    Large = "lg"
}
declare enum ComponentStatus {
    Default = "default",
    Loading = "loading",
    Error = "error",
    Valid = "valid",
    Disabled = "disabled"
}
declare enum ComponentOrientation {
    Horizontal = "horizontal",
    Vertical = "vertical"
}
interface Color {
    hex: string;
    name: string;
}
interface Gradient {
    start: InfluxColors;
    stop: InfluxColors;
}
declare enum Gradients {
    BeijingEclipse = "BeijingEclipse",
    DistantNebula = "DistantNebula",
    SpirulinaSmoothie = "SpirulinaSmoothie",
    CephalopodInk = "CephalopodInk",
    DarkChocolate = "DarkChocolate",
    LASunset = "LASunset",
    PolarExpress = "PolarExpress",
    RebelAlliance = "RebelAlliance",
    JungleDusk = "JungleDusk",
    SavannaHeat = "SavannaHeat",
    DocScott = "DocScott",
    GundamPilot = "GundamPilot",
    TropicalTourist = "TropicalTourist",
    JalapenoTaco = "JalapenoTaco",
    FuyuPersimmon = "FuyuPersimmon",
    DesertFestival = "DesertFestival",
    MiyazakiSky = "MiyazakiSky",
    GarageBand = "GarageBand",
    MangoGrove = "MangoGrove",
    ScotchBonnet = "ScotchBonnet",
    BrooklynCowboy = "BrooklynCowboy",
    PastelGothic = "PastelGothic",
    LowDifficulty = "LowDifficulty",
    CitrusSodapop = "CitrusSodapop",
    CaliforniaCampfire = "CaliforniaCampfire",
    SynthPop = "SynthPop",
    CottonCandy = "CottonCandy",
    HotelBreakfast = "HotelBreakfast",
    CandyApple = "CandyApple",
    JustPeachy = "JustPeachy",
    MagicCarpet = "MagicCarpet",
    CruisingAltitude = "CruisingAltitude",
    CoconutLime = "CoconutLime",
    MillennialAvocado = "MillennialAvocado",
    GoldenHour = "GoldenHour",
    PastryCafe = "PastryCafe",
    KawaiiDesu = "KawaiiDesu",
    RobotLogic = "RobotLogic",
    MintyFresh = "MintyFresh",
    SimpleCream = "SimpleCream",
    // Brand Gradients
    WarpSpeed = "WarpSpeed",
    PowerStone = "PowerStone",
    MilkyWay = "MilkyWay",
    LazyAfternoon = "LazyAfternoon",
    NineteenEightyFour = "NineteenEightyFour",
    RadioactiveWarning = "RadioactiveWarning",
    LostGalaxy = "LostGalaxy",
    GrapeSoda = "GrapeSoda",
    LavenderLatte = "LavenderLatte",
    OminousFog = "OminousFog",
    // Single Hue Gradients
    DefaultLight = "DefaultLight",
    Default = "Default",
    DefaultDark = "DefaultDark",
    PrimaryLight = "PrimaryLight",
    Primary = "Primary",
    PrimaryDark = "PrimaryDark",
    SecondaryLight = "SecondaryLight",
    Secondary = "Secondary",
    SecondaryDark = "SecondaryDark",
    SuccessLight = "SuccessLight",
    Success = "Success",
    SuccessDark = "SuccessDark",
    WarningLight = "WarningLight",
    Warning = "Warning",
    WarningDark = "WarningDark",
    DangerLight = "DangerLight",
    Danger = "Danger",
    DangerDark = "DangerDark"
}
declare enum DropdownMenuTheme {
    Amethyst = "amethyst",
    Malachite = "malachite",
    Sapphire = "sapphire",
    Onyx = "onyx"
}
interface DropdownMenuScrollbarColors {
    thumbStartColor: InfluxColors;
    thumbStopColor: InfluxColors;
}
declare enum DropdownItemType {
    Dot = "dot",
    Checkbox = "checkbox",
    None = "none"
}
declare enum Direction {
    Left = "CaretLeft",
    Right = "CaretRight"
}
declare enum ButtonShape {
    Default = "none",
    Square = "square",
    StretchToFit = "stretch"
}
declare enum ButtonType {
    Button = "button",
    Submit = "submit"
}
declare enum InfluxColors {
    // Greys
    Obsidian = "#0f0e15",
    Raven = "#181820",
    Kevlar = "#202028",
    Castle = "#292933",
    Onyx = "#31313d",
    Pepper = "#383846",
    Smoke = "#434453",
    Graphite = "#545667",
    Storm = "#676978",
    Mountain = "#757888",
    Wolf = "#8e91a1",
    Sidewalk = "#999dab",
    Forge = "#a4a8b6",
    Mist = "#bec2cc",
    Chromium = "#c6cad3",
    Platinum = "#d4d7dd",
    Pearl = "#e7e8eb",
    Whisper = "#eeeff2",
    Cloud = "#f6f6f8",
    Ghost = "#fafafc",
    White = "#ffffff",
    // Blues
    Abyss = "#120653",
    Sapphire = "#0b3a8d",
    Ocean = "#066fc5",
    Pool = "#00a3ff",
    Laser = "#00C9FF",
    Hydrogen = "#6BDFFF",
    Neutrino = "#BEF0FF",
    Yeti = "#F0FCFF",
    // Purples
    Shadow = "#2b007e",
    Void = "#5c10a0",
    Amethyst = "#8e1fc3",
    Star = "#be2ee4",
    Comet = "#ce58eb",
    Potassium = "#dd84f1",
    Moonstone = "#ebadf8",
    Twilight = "#fad9ff",
    // Greens
    Gypsy = "#003e34",
    Emerald = "#006f49",
    Viridian = "#009f5f",
    Rainforest = "#34bb55",
    Honeydew = "#67d74e",
    Krypton = "#9bf445",
    Wasabi = "#c6f98e",
    Mint = "#f3ffd6",
    // Yellows
    Oak = "#3F241F",
    Topaz = "#E85B1C",
    Tiger = "#F48D38",
    Pineapple = "#FFB94A",
    Thunder = "#FFD255",
    Sulfur = "#FFE480",
    Daisy = "#FFF6B8",
    Banana = "#FFFDDE",
    // Reds
    Basalt = "#2F1F29",
    Ruby = "#BF3D5E",
    Fire = "#DC4E58",
    Curacao = "#F95F53",
    Dreamsicle = "#FF8564",
    Tungsten = "#FFB6A0",
    Marmelade = "#FFDCCF",
    Flan = "#FFF7F4",
    // Brand Colors
    Chartreuse = "#D6F622",
    DeepPurple = "#13002D",
    Magenta = "#BF2FE5",
    Galaxy = "#9394FF",
    Pulsar = "#513CC6"
}
declare enum IconFont {
    AddCell = "add-cell",
    Alerts = "alerts",
    AlertTriangle = "alert-triangle",
    Annotate = "annotate",
    AnnotatePlus = "annotate-plus",
    AuthZero = "authzero",
    BarChart = "bar-chart",
    Bell = "bell",
    BellRinging = "bell-ringing",
    BellSolid = "bell-solid",
    BookCode = "book-code",
    BookPencil = "book-pencil",
    Book = "book",
    Brush = "brush",
    BucketOutline = "bucket-outline",
    BucketSolid = "bucket-solid",
    Calendar = "calendar",
    Capacitor = "capacitor2",
    CaretDown = "caret-down",
    CaretLeft = "caret-left",
    CaretRight = "caret-right",
    CaretUp = "caret-up",
    Chat = "chat",
    Checkmark = "checkmark",
    Circle = "circle",
    CircleThick = "circle-thick",
    Clock = "clock",
    Cloud = "cloud",
    CogOutline = "cog-outline",
    CogThick = "cog-thick",
    Collapse = "collapse",
    CrownOutline = "crown-outline",
    CrownSolid = "crown2",
    Cube = "cube",
    Cubo = "cubo",
    CuboNav = "cubo-nav",
    Cubouniform = "cubo-uniform",
    CurrencyEUR = "currency-eur",
    CurrencyGBP = "currency-gbp",
    CurrencyUSD = "currency-usd",
    Dashboards = "dashboards",
    DashF = "dash-f",
    DashH = "dash-h",
    DashJ = "dash-j",
    Disks = "disks",
    DisksNav = "disks-nav",
    Download = "download",
    DragToExpand = "drag-to-expand",
    Duplicate = "duplicate",
    Erlenmeyer = "erlenmeyer",
    ExpandA = "expand-a",
    ExpandB = "expand-b",
    Export = "export",
    Eye = "eye",
    Function = "fn",
    FunnelOutline = "funnel-outline",
    FunnelSolid = "funnel-solid",
    EyeClosed = "eye-closed",
    EyeOpen = "eye-open",
    GitHub = "github",
    Google = "google",
    GraphLine = "graphline-2",
    Group = "group",
    HeartSolid = "heart-solid",
    Heroku = "heroku",
    HerokuSimple = "heroku-simple",
    Import = "import",
    Layers = "layers",
    Link = "link",
    Lock = "lock",
    Maximize = "maximize",
    Minimize = "minimize",
    Moon = "moon",
    Merge = "merge",
    NavChat = "nav-chat",
    OAuth = "oauth",
    Octagon = "octagon",
    Okta = "okta",
    Pause = "pause",
    Pencil = "pencil",
    Play = "play",
    Plus = "plus",
    PlusSkinny = "plus-skinny",
    Polaroid = "polaroid",
    Pulse = "pulse-c",
    Redo = "redo",
    Refresh = "refresh",
    Remove = "remove",
    Search = "search",
    Server = "server2",
    Share = "share",
    ShareSolid = "share-solid",
    Shield = "shield",
    ShieldSolid = "shield-solid",
    Shuffle = "shuffle",
    Square = "square",
    SquareCheck = "square-check",
    Star = "star",
    Stop = "stop",
    Sun = "sun",
    TextBlock = "text-block",
    Trash = "trash",
    Triangle = "triangle",
    Undo = "undo",
    Upgrade = "upgrade",
    User = "user",
    UserAdd = "user-add",
    UserOutline = "user-outline",
    UserRemove = "user-remove",
    UsersDuo = "users-duo",
    UsersTrio = "users-trio",
    Wand = "wand",
    Wood = "wood",
    Wrench = "wrench",
    WrenchNav = "wrench-nav",
    Zap = "zap"
}
declare enum Columns {
    One = 1,
    Two = 2,
    Three = 3,
    Four = 4,
    Five = 5,
    Six = 6,
    Seven = 7,
    Eight = 8,
    Nine = 9,
    Ten = 10,
    Eleven = 11,
    Twelve = 12
}
declare enum Sort {
    Descending = "desc",
    Ascending = "asc",
    None = "none"
}
declare enum Alignment {
    Left = "left",
    Center = "center",
    Right = "right"
}
declare enum VerticalAlignment {
    Top = "top",
    Middle = "middle",
    Bottom = "bottom"
}
declare enum JustifyContent {
    FlexStart = "flex-start",
    Center = "center",
    FlexEnd = "flex-end",
    SpaceBetween = "space-between",
    SpaceAround = "space-around"
}
declare enum AlignItems {
    FlexStart = "flex-start",
    Center = "center",
    FlexEnd = "flex-end",
    Stretch = "stretch"
}
declare enum FlexDirection {
    Row = "row",
    RowReverse = "row-reverse",
    Column = "column",
    ColumnReverse = "column-reverse"
}
declare enum RemoteDataState {
    NotStarted = "NotStarted",
    Loading = "Loading",
    Done = "Done",
    Error = "Error"
}
declare enum AutoComplete {
    On = "on",
    Off = "off"
}
declare enum Orientation {
    Vertical = "vertical",
    Horizontal = "horizontal"
}
declare enum BorderType {
    None = "none",
    Horizontal = "horizontal",
    Vertical = "vertical",
    Both = "both",
    All = "all"
}
interface TimeRange {
    lower: string;
    upper?: string | null;
    seconds?: number;
    format?: string;
    label?: string;
    duration?: string;
}
declare enum InputType {
    Text = "text",
    Number = "number",
    Password = "password",
    Email = "email",
    Checkbox = "checkbox",
    Range = "range"
}
declare enum InputToggleType {
    Checkbox = "checkbox",
    Radio = "radio"
}
declare enum AutoInputMode {
    Auto = "auto",
    Custom = "custom"
}
declare enum PopoverInteraction {
    Hover = "hover",
    Click = "click",
    None = "none"
}
declare enum PopoverPosition {
    Above = "above",
    Below = "below",
    ToTheLeft = "to-left",
    ToTheRight = "to-right"
}
declare enum Appearance {
    Solid = "solid",
    Outline = "outline"
}
declare enum EncType {
    Application = "application/x-www-form-urlencoded",
    Multipart = "multipart/form-data",
    Text = "text/plain"
}
declare enum Method {
    Post = "post",
    Get = "get",
    Dialog = "dialog"
}
declare enum Wrap {
    Hard = "hard",
    Soft = "soft",
    Off = "off"
}
interface Coordinates {
    x: number;
    y: number;
}
declare enum LinkTarget {
    Blank = "_blank",
    Parent = "_parent",
    Self = "_self",
    Top = "_top"
}
declare enum LinkRel {
    Alternate = "alternate",
    Author = "author",
    Bookmark = "bookmark",
    External = "external",
    Help = "help",
    License = "license",
    Next = "next",
    NoFollow = "nofollow",
    NoOpener = "noopener",
    NoReferrer = "noreferrer",
    Prev = "prev",
    Search = "search",
    Tag = "tag"
}
declare enum Typeface {
    IBMPlexMono = "ibm-plex-mono",
    Rubik = "rubik"
}
declare enum HeadingElement {
    H1 = "h1",
    H2 = "h2",
    H3 = "h3",
    H4 = "h4",
    H5 = "h5",
    H6 = "h6",
    Span = "span",
    Div = "div",
    P = "p"
}
declare enum FontWeight {
    Light = "300",
    Regular = "400",
    Medium = "500",
    Bold = "700",
    Black = "900"
}
declare enum Breakpoint {
    None = 0,
    Small,
    Medium,
    Large
}
interface Props extends StandardFunctionProps {
    /** Alert color */
    color: ComponentColor;
    /** Icon to be displayed to the left of text */
    icon?: IconFont;
}
type AlertRef = HTMLDivElement;
declare const Alert: React.ForwardRefExoticComponent<Props & React.RefAttributes<HTMLDivElement>>;
interface AppHeaderProps extends StandardFunctionProps {
    /** Height of header bar */
    size?: ComponentSize;
}
type AppHeaderRef = HTMLDivElement;
interface AppHeaderLogoProps extends StandardFunctionProps {
    /** Image source url */
    src?: string;
    /** Size of logo */
    size?: ComponentSize;
}
type AppHeaderLogoRef = HTMLDivElement;
declare const AppHeaderLogo: React.ForwardRefExoticComponent<AppHeaderLogoProps & React.RefAttributes<HTMLDivElement>>;
declare class AppHeader extends Component<AppHeaderProps> {
    static readonly displayName = "AppHeader";
    static AppHeader: React.ForwardRefExoticComponent<AppHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static Logo: React.ForwardRefExoticComponent<AppHeaderLogoProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
type AppWrapperType = "standard" | "funnel";
interface AppWrapperProps extends StandardFunctionProps {
    /** Hides the page header and nav menu so that the contents can take up the whole screen */
    presentationMode?: boolean;
    /** Controls responsive layout (can be either "page" for "funnel") */
    type?: AppWrapperType;
}
type AppWrapperRef = HTMLDivElement;
declare const AppWrapper: React.ForwardRefExoticComponent<AppWrapperProps & React.RefAttributes<HTMLDivElement>>;
interface ButtonBaseProps extends StandardFunctionProps {
    /** Function to be called on button click */
    onClick?: (e?: MouseEvent<HTMLButtonElement>) => void;
    /** Function to be called on mouse over */
    onMouseOver?: (e?: MouseEvent<HTMLButtonElement>) => void;
    /** Function to be called on mouse out */
    onMouseOut?: (e?: MouseEvent<HTMLButtonElement>) => void;
    /** Function to be called on mouse enter */
    onMouseEnter?: (e?: MouseEvent<HTMLButtonElement>) => void;
    /** Function to be called on mouse leave */
    onMouseLeave?: (e?: MouseEvent<HTMLButtonElement>) => void;
    /** Text to be displayed on hover tooltip */
    titleText?: string;
    /** Keyboard control tab order  */
    tabIndex?: number;
    /** Button color */
    color?: ComponentColor;
    /** Button size */
    size?: ComponentSize;
    /** Square or rectangle */
    shape?: ButtonShape;
    /** Button status state default, loading, or disabled */
    status?: ComponentStatus;
    /** Toggles button highlighted active state */
    active?: boolean;
    /** Button type of 'button' or 'submit' */
    type?: ButtonType;
}
type ButtonBaseRef = HTMLButtonElement;
declare const ButtonBase: React.ForwardRefExoticComponent<ButtonBaseProps & React.RefAttributes<HTMLButtonElement>>;
interface ButtonProps extends ButtonBaseProps {
    /** Text to be displayed on button */
    text?: string;
    /** Icon to be displayed to the left of text or in place of text */
    icon?: IconFont;
    /** Reverse ordering of text and icon */
    placeIconAfterText?: boolean;
}
type ButtonRef = ButtonBaseRef;
declare const Button: React.ForwardRefExoticComponent<ButtonProps & React.RefAttributes<HTMLButtonElement>>;
interface ButtonGroupProps extends StandardFunctionProps {
    /** Stacking axis of buttons */
    orientation?: Orientation;
}
type ButtonGroupRef = HTMLDivElement;
declare const ButtonGroup: React.ForwardRefExoticComponent<ButtonGroupProps & React.RefAttributes<HTMLDivElement>>;
interface ConfirmationButtonProps extends Omit<ButtonProps, "onClick" | "active" | "type" | "onMouseEnter" | "onMouseLeave" | "onMouseOver" | "onMouseOut"> {
    /** Text to appear in confirmation popover */
    confirmationLabel: string;
    /** Text to appear in confirmation button */
    confirmationButtonText: string;
    /** Color of confirmation button */
    confirmationButtonColor?: ComponentColor;
    /** Popover dialog color */
    popoverColor?: ComponentColor;
    /** Means of applying color to popover */
    popoverAppearance?: Appearance;
    /** Allows customization of Popover */
    popoverClassName?: string;
    /** Allows customization of Popover */
    popoverStyle?: CSSProperties;
    /** Callback function fired when state changes to "show" */
    onShow?: () => void;
    /** Callback function fired when state changes to "hide" */
    onHide?: () => void;
    /** Function to call when confirmation is clicked, passes 'value' prop in */
    onConfirm: (returnValue?: any) => void;
    /** Optional value to have passed back via onConfirm */
    returnValue?: any;
}
declare const ConfirmationButton: FunctionComponent<ConfirmationButtonProps>;
interface CTAButtonProps extends Omit<ButtonBaseProps, "size"> {
    /** Text to be displayed on button */
    text?: string;
    /** Icon to be displayed to the left of text or in place of text */
    icon?: IconFont;
    /** Reverse ordering of text and icon */
    placeIconAfterText?: boolean;
}
type CTAButtonRef = ButtonBaseRef;
declare const CTAButton: React.ForwardRefExoticComponent<CTAButtonProps & React.RefAttributes<HTMLButtonElement>>;
interface DismissButtonProps extends ButtonBaseProps {
}
type DismissButtonRef = ButtonBaseRef;
declare const DismissButton: React.ForwardRefExoticComponent<DismissButtonProps & React.RefAttributes<HTMLButtonElement>>;
interface SquareButtonProps extends Omit<ButtonBaseProps, "Shape"> {
    /** Icon to be displayed to the left of text or in place of text */
    icon: IconFont;
}
type SquareButtonRef = ButtonBaseRef;
declare const SquareButton: React.ForwardRefExoticComponent<SquareButtonProps & React.RefAttributes<HTMLButtonElement>>;
interface LinkButtonProps extends Omit<ButtonProps, "onClick" | "onMouseOver" | "onMouseOut" | "onMouseEnter" | "onMouseLeave" | "type"> {
    /** Destination for link button */
    href: string;
    /** Where to open to the link */
    target?: LinkTarget | string;
    /** Describes the relationship between this document and the linked document */
    rel?: LinkRel;
}
type LinkButtonRef = HTMLAnchorElement;
declare const LinkButton: React.ForwardRefExoticComponent<LinkButtonProps & React.RefAttributes<HTMLAnchorElement>>;
interface CTALinkButtonProps extends Omit<LinkButtonProps, "size"> {
}
type CTALinkButtonRef = LinkButtonRef;
declare const CTALinkButton: React.ForwardRefExoticComponent<CTALinkButtonProps & React.RefAttributes<HTMLAnchorElement>>;
interface Props$0 {
    /** Function to call when click outside is detected */
    onClickOutside: (e: any) => void;
}
declare class ClickOutside extends PureComponent<Props$0> {
    static readonly displayName = "ClickOutside";
    componentDidMount(): void;
    componentWillUnmount(): void;
    render(): string | number | boolean | {} | React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)> | React.ReactPortal | null | undefined;
    private handleClickOutside;
}
interface ColorPickerProps extends StandardFunctionProps {
    /** currently selected color */
    color: string;
    /** Function to be called on color select */
    onChange: (color: string, status?: ComponentStatus) => void;
    /** Array of colors to be displayed in color picker */
    colors?: Color[];
    /** Prevent focus from leaving the input */
    maintainInputFocus?: boolean;
    /** How many color swatches to render in each row */
    swatchesPerRow?: number;
    /** Enforces hexcode format by defult, pass in your own function to customize */
    validationFunc?: ValidationFunction;
    /** Characters matching this expression will be stripped out of the value before being passed into onChange */
    invalidChars?: RegExp;
}
type ColorPickerRef = HTMLDivElement;
declare const ColorPicker: React.ForwardRefExoticComponent<ColorPickerProps & React.RefAttributes<HTMLDivElement>>;
interface ColorPickerSwatchProps extends StandardFunctionProps {
    /** Color name */
    name: string;
    /** Color hex value */
    hex: string;
    /** Function to be called on color click */
    onClick: (hex: string) => void;
    /** Used to determine percentage width of parent to take up */
    swatchesPerRow: number;
    /** Index - used to determine if corners are rounded or not */
    index: number;
    /** Number of colors used in Color Picker, used to determine rounded corners */
    swatchesCount: number;
}
type ColorPickerSwatchRef = HTMLDivElement;
declare const ColorPickerSwatch: React.ForwardRefExoticComponent<ColorPickerSwatchProps & React.RefAttributes<HTMLDivElement>>;
// react-scrollbars-custom uses a highly unusual type
// to presumably handle touch and mouse events simultaneously
type FusionScrollEvent = UIEvent<HTMLDivElement> & ScrollState; // Using this custom type makes typescript happy
// and exposes enough typing to properly interface
// with the onScroll and onUpdate props
// Using this custom type makes typescript happy
// and exposes enough typing to properly interface
// with the onScroll and onUpdate props
type FusionScrollHandler = (scrollValues: FusionScrollEvent, prevScrollValues?: ScrollState) => void;
interface DapperScrollbarsProps extends StandardFunctionProps {
    /** Toggle display of tracks when no scrolling is necessary */
    removeTracksWhenNotUsed?: boolean;
    /** Toggle display of vertical track when no scrolling is necessary */
    removeTrackYWhenNotUsed?: boolean;
    /** Toggle display of horizontal track when no scrolling is necessary */
    removeTrackXWhenNotUsed?: boolean;
    /** Disable scrolling horizontally */
    noScrollX?: boolean;
    /** Disable scrolling vertically */
    noScrollY?: boolean;
    /** Disable scrolling */
    noScroll?: boolean;
    /** Gradient start color */
    thumbStartColor?: string | InfluxColors;
    /** Gradient end color */
    thumbStopColor?: string | InfluxColors;
    /** Hide scrollbar when not actively scrolling */
    autoHide?: boolean;
    /** Scroll container will grow to fit the content width and height */
    autoSize?: boolean;
    /** Scroll container will grow to fit the content width */
    autoSizeWidth?: boolean;
    /** Scroll container will grow to fit the content height */
    autoSizeHeight?: boolean;
    /** Vertical scroll position in pixels */
    scrollTop?: number;
    /** Horizontal scroll position in pixels */
    scrollLeft?: number;
    /** Function to be called when called scroll event fires */
    onScroll?: FusionScrollHandler;
    /** Function called after component updated */
    onUpdate?: FusionScrollHandler;
}
declare const DapperScrollbars: FunctionComponent<DapperScrollbarsProps>;
interface DatePickerProps extends StandardFunctionProps {
    /** Label for input field */
    label: string;
    /** Date value */
    dateTime?: string | null;
    /** Function called once a date is selected */
    onSelectDate: (date: string) => void;
}
type DatePickerRef = HTMLDivElement;
declare const DatePicker: React.ForwardRefExoticComponent<DatePickerProps & React.RefAttributes<HTMLDivElement>>;
interface FlexBoxProps extends StandardFunctionProps {
    /** Vertical or horizontal flex alignment */
    direction?: FlexDirection;
    /** Inserted margin between children */
    margin?: ComponentSize;
    /** Can be FlexStart, FlexEnd, Center, SpaceBetween, or SpaceAround */
    justifyContent?: JustifyContent;
    /** Can be FlexStart, FlexEnd, Center, or Stretch */
    alignItems?: AlignItems;
    /** stretches component spacer to fit parent width */
    stretchToFitWidth?: boolean;
    /** stretches component spacer to fit parent height */
    stretchToFitHeight?: boolean;
}
type FlexBoxRef = HTMLDivElement;
interface FlexBoxChildProps extends StandardFunctionProps {
    /** Optional fixed width of element */
    basis?: number;
    /** Maximumn proportional width to grow until */
    grow?: number;
    /** Minimum proportional width to shrink until */
    shrink?: number;
}
type FlexBoxChildRef = HTMLDivElement;
declare const FlexBoxChild: React.ForwardRefExoticComponent<FlexBoxChildProps & React.RefAttributes<HTMLDivElement>>;
declare class FlexBox extends Component<FlexBoxProps> {
    static readonly displayName = "FlexBox";
    static FlexBox: React.ForwardRefExoticComponent<FlexBoxProps & React.RefAttributes<HTMLDivElement>>;
    static Child: React.ForwardRefExoticComponent<FlexBoxChildProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface DateRangePickerProps extends StandardFunctionProps {
    /** Object of {upper: string, lower: string | null, seconds: number, format: string, label: string, duration: string} */
    timeRange: TimeRange;
    /** Function called when time range is set */
    onSetTimeRange: (timeRange: TimeRange) => void;
}
type DateRangePickerRef = FlexBoxRef;
declare const DateRangePicker: React.ForwardRefExoticComponent<DateRangePickerProps & React.RefAttributes<HTMLDivElement>>;
interface DraggableResizerProps extends StandardFunctionProps {
    /** Orientation the draggable panels stack in */
    handleOrientation: Orientation;
    /** Expects and array of numbers between 0 - 1 */
    handlePositions: number[];
    /** Returns the updated array of numbers between 0 - 1, used to manage state */
    onChangePositions: (positions: number[]) => void;
    /** Gradient theme for handle */
    handleGradient?: Gradients;
}
interface DraggableResizerPanelProps extends StandardFunctionProps {
    /** Panel will not shrink past this size (experimental, not guaranteed to work) */
    minSizePixels?: number;
    sizePercent?: number; /** Test ID for Integration Tests */
    /** Test ID for Integration Tests */
    /** Test ID for Integration Tests */
    /** Test ID for Integration Tests */
}
type DraggableResizerPanelRef = HTMLDivElement;
declare const DraggableResizerPanel: React.ForwardRefExoticComponent<DraggableResizerPanelProps & React.RefAttributes<HTMLDivElement>>;
declare class DraggableResizer extends Component<DraggableResizerProps> {
    static readonly displayName = "DraggableResizer";
    static DraggableResizer: React.FunctionComponent<DraggableResizerProps>;
    static Panel: React.ForwardRefExoticComponent<DraggableResizerPanelProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
declare enum MenuStatus {
    Open = "open",
    Closed = "closed"
}
interface DropdownProps extends StandardFunctionProps {
    /** Component to render as the button (use Dropdown.Button) */
    button: (active: boolean, onClick: (e: MouseEvent<HTMLElement>) => void) => JSX.Element;
    /** Component to render as the menu (use Dropdown.Menu) */
    menu: (onCollapse?: () => void) => JSX.Element;
    /** Renders the menu element above the button instead of below */
    dropUp?: boolean;
    /** Optional method that is triggered when the user clicks outside of/away from the dropdown */
    onClickAway?: () => void;
    /**
     * optional way for the owner of this dropdown to set the menu to be open or closed:
     * 'open':  the menu will be open
     * 'closed': the menu will be closed
     * any other string will be ignored.
     *
     * and the menu  (open/closed) only changes programmatically when this value changes.
     * so the owner is responsible for resetting this value
     * (if the string is set to 'open', and then the user closes it, and the code sets it to open again,
     * unless the code sets it to something else in between (like null or 'close'),
     * then nothing will happen- the menu will not open)
     * */
    menuOpen?: MenuStatus;
}
type DropdownRef = HTMLDivElement;
interface DropdownMenuProps extends StandardFunctionProps {
    /** Pixel height after which the dropdown menu will scroll */
    maxHeight?: number;
    /** Controls coloration of the dropdown menu and all subcomponents */
    theme?: DropdownMenuTheme;
    /** Disable scrolling horizontally */
    noScrollX?: boolean;
    /** Disable scrolling vertically */
    noScrollY?: boolean;
    /** Automatically scroll to selected item when dropdown is opened */
    scrollToSelected?: boolean;
    /** Function to handle closing the menu when a child item is clicked */
    onCollapse?: () => void;
    /** Pass through ref for contents element within scrollbars */
    contentsRef?: RefObject<DropdownMenuContentsRef>;
    /** Useful for customizing appearance of the contents element within scrollbars */
    contentsStyle?: CSSProperties;
    /** Controls autoHide behavior of scrollbars within the menu */
    autoHideScrollbars?: boolean;
}
type DropdownMenuRef = HTMLDivElement;
type DropdownMenuContentsRef = HTMLDivElement;
declare const DropdownMenu: React.ForwardRefExoticComponent<DropdownMenuProps & React.RefAttributes<HTMLDivElement>>;
interface DropdownButtonProps extends StandardFunctionProps {
    /** Function to be called on click of dropdown button */
    onClick: (e: MouseEvent<HTMLButtonElement>) => void;
    /** Button status state default, loading, or disabled */
    status?: ComponentStatus;
    /** Button color */
    color?: ComponentColor;
    /** Button size */
    size?: ComponentSize;
    /** Toggles button highlighted active state */
    active?: boolean;
    /** Icon to be displayed to the left of text or in place of text */
    icon?: IconFont;
    /** Text to be displayed on hover tooltip */
    title?: string;
}
type DropdownButtonRef = ButtonBaseRef;
declare const DropdownButton: React.ForwardRefExoticComponent<DropdownButtonProps & React.RefAttributes<HTMLButtonElement>>;
interface DropdownItemProps extends StandardFunctionProps {
    /** Value to be returned via the onClick function */
    value?: any;
    /** Whether or not the item should have selected styling */
    selected?: boolean;
    /** Controls which style of dropdown item is rendered */
    type?: DropdownItemType;
    /** When a dropdown item is clicked, its `value` prop is returned via `onChange` */
    onClick?: (value?: any) => void;
    /** Controls whether the text contents of this item wrap or not */
    wrapText?: boolean;
    /** Title attribute */
    title?: string;
    /** Prevents any interaction with this element, including the onClick function */
    disabled?: boolean;
}
type DropdownItemRef = HTMLDivElement;
declare const DropdownItem: React.ForwardRefExoticComponent<DropdownItemProps & React.RefAttributes<HTMLDivElement>>;
interface DropdownItemEmptyProps extends StandardFunctionProps {
    /** Controls whether the text contents of this item wrap or not */
    wrapText?: boolean;
}
type DropdownItemEmptyRef = HTMLDivElement;
declare const DropdownItemEmpty: React.ForwardRefExoticComponent<DropdownItemEmptyProps & React.RefAttributes<HTMLDivElement>>;
interface DropdownLinkItemProps extends StandardFunctionProps {
    /** Whether or not the item should have selected styling */
    selected: boolean;
    /** Controls which style of dropdown item is rendered */
    type?: DropdownItemType;
    /** Controls whether the text contents of this item wrap or not */
    wrapText?: boolean;
    /** Renders the element in a disabled state, does not affect functionality */
    disabled?: boolean;
}
type DropdownLinkItemRef = HTMLDivElement;
declare const DropdownLinkItem: React.ForwardRefExoticComponent<DropdownLinkItemProps & React.RefAttributes<HTMLDivElement>>;
interface DropdownDividerProps extends StandardFunctionProps {
    /** Text to be displayed on divider, a line will be displayed if no text is provided */
    text?: string;
}
type DropdownDividerRef = HTMLDivElement;
declare const DropdownDivider: React.ForwardRefExoticComponent<DropdownDividerProps & React.RefAttributes<HTMLDivElement>>;
declare class Dropdown extends Component<DropdownProps> {
    static readonly displayName = "Dropdown";
    static Dropdown: React.ForwardRefExoticComponent<DropdownProps & React.RefAttributes<HTMLDivElement>>;
    static Menu: React.ForwardRefExoticComponent<DropdownMenuProps & React.RefAttributes<HTMLDivElement>>;
    static Button: React.ForwardRefExoticComponent<DropdownButtonProps & React.RefAttributes<HTMLButtonElement>>;
    static Item: React.ForwardRefExoticComponent<DropdownItemProps & React.RefAttributes<HTMLDivElement>>;
    static ItemEmpty: React.ForwardRefExoticComponent<DropdownItemEmptyProps & React.RefAttributes<HTMLDivElement>>;
    static LinkItem: React.ForwardRefExoticComponent<DropdownLinkItemProps & React.RefAttributes<HTMLDivElement>>;
    static Divider: React.ForwardRefExoticComponent<DropdownDividerProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface MultiSelectDropdownProps extends StandardFunctionProps {
    /** Text to render in button as currently selected option */
    selectedOptions: string[];
    /** List of options to render in menu */
    options: string[];
    /** Fires when an option is clicked, used to update state */
    onSelect: (option: string) => void;
    /** Text to display when no options are selected */
    emptyText?: string;
    /** Optional status of button */
    buttonStatus?: ComponentStatus;
    /** Optional color of button */
    buttonColor?: ComponentColor;
    /** Optional size of button */
    buttonSize?: ComponentSize;
    /** Optional icon to render in button */
    buttonIcon?: IconFont;
    /** Optional theme of menu */
    menuTheme?: DropdownMenuTheme;
    /** Optional maximum pixel height menu */
    menuMaxHeight?: number;
    /** Renders the menu element above the button instead of below */
    dropUp?: boolean;
}
type MultiSelectDropdownRef = DropdownRef;
declare const MultiSelectDropdown: React.ForwardRefExoticComponent<MultiSelectDropdownProps & React.RefAttributes<HTMLDivElement>>;
interface SelectDropdownProps extends StandardFunctionProps {
    /** Text to render in button as currently selected option */
    selectedOption: string;
    /** List of options to render in menu */
    options: string[];
    /** Fires when an option is clicked, used to update state */
    onSelect: (option: string) => void;
    /** Optional status of button */
    buttonStatus?: ComponentStatus;
    /** Optional color of button */
    buttonColor?: ComponentColor;
    /** Optional size of button */
    buttonSize?: ComponentSize;
    /** Optional icon to render in button */
    buttonIcon?: IconFont;
    /** Optional theme of menu */
    menuTheme?: DropdownMenuTheme;
    /** Optional maximum pixel height menu */
    menuMaxHeight?: number;
    /** Renders the menu element above the button instead of below */
    dropUp?: boolean;
}
type SelectDropdownRef = DropdownRef;
declare const SelectDropdown: React.ForwardRefExoticComponent<SelectDropdownProps & React.RefAttributes<HTMLDivElement>>;
interface EmptyStateProps extends StandardFunctionProps {
    /** Controls vertical padding in container and font size of children */
    size?: ComponentSize;
}
type EmptyStateRef = HTMLDivElement;
declare class EmptyState extends Component<EmptyStateProps> {
    static readonly displayName = "EmptyState";
    static EmptyState: React.ForwardRefExoticComponent<EmptyStateProps & React.RefAttributes<HTMLDivElement>>;
    static Text: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLHeadingElement>>;
    static SubText: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLParagraphElement>>;
    render(): JSX.Element;
}
type EmptyStateTextRef = HTMLHeadingElement;
declare const EmptyStateText: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLHeadingElement>>;
type EmptyStateSubTextRef = HTMLParagraphElement;
declare const EmptyStateSubText: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLParagraphElement>>;
interface FunnelPageProps extends StandardFunctionProps {
    /** Places a logo in the top left corner */
    logo?: JSX.Element;
    /** Primary page background color */
    backgroundColor?: InfluxColors | string;
    /** First background accent color */
    accentColorA?: InfluxColors | string;
    /** Second background accent color */
    accentColorB?: InfluxColors | string;
    /** Control inline styles of the outermost elemment */
    pageStyle?: CSSProperties;
    /** Renders a graphic in the funnel page */
    enableGraphic?: boolean;
}
type FunnelPageRef = HTMLDivElement;
interface FunnelPageFooterProps extends StandardFunctionProps {
}
type FunnelPageFooterRef = HTMLDivElement;
declare const FunnelPageFooter: React.ForwardRefExoticComponent<FunnelPageFooterProps & React.RefAttributes<HTMLDivElement>>;
interface FunnelPageFooterSectionProps extends StandardFunctionProps {
}
type FunnelPageFooterSectionRef = HTMLDivElement;
declare const FunnelPageFooterSection: React.ForwardRefExoticComponent<FunnelPageFooterSectionProps & React.RefAttributes<HTMLDivElement>>;
declare class FunnelPage extends Component<FunnelPageProps> {
    static readonly displayName = "FunnelPage";
    static FunnelPage: React.ForwardRefExoticComponent<FunnelPageProps & React.RefAttributes<HTMLDivElement>>;
    static Footer: React.ForwardRefExoticComponent<FunnelPageFooterProps & React.RefAttributes<HTMLDivElement>>;
    static FooterSection: React.ForwardRefExoticComponent<FunnelPageFooterSectionProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface FormProps extends StandardFunctionProps {
    /** Form submit URI */
    action?: string;
    /** A space-delimited list of character encodings. */
    acceptCharset?: string;
    /** Allows or disallows browser autocomplete functionality */
    autoComplete?: AutoComplete;
    /** Type of content to be submitted to the server */
    encType?: EncType;
    /** HTTP Method to be used on form submit */
    method?: Method;
    /** Input field name attribute */
    name?: string;
    /** Enable or disable form validation */
    noValidate?: boolean;
    /** Function to be called on form submit */
    onSubmit?: (e: React.FormEvent) => void;
    /** Context name or keyword */
    target?: string;
    /** If true prevents default event during onSubmit */
    preventDefault?: boolean;
}
interface FormBoxProps extends StandardFunctionProps {
}
type FormBoxRef = HTMLDivElement;
declare const FormBox: React.ForwardRefExoticComponent<FormBoxProps & React.RefAttributes<HTMLDivElement>>;
interface FormDividerProps extends StandardFunctionProps {
    /** Optional coloration for horizontal rule in divider */
    lineColor?: InfluxColors | string;
}
type FormDividerRef = HTMLDivElement;
declare const FormDivider: React.ForwardRefExoticComponent<FormDividerProps & React.RefAttributes<HTMLDivElement>>;
interface FormElementProps extends StandardFunctionProps {
    /** Label Text */
    label: string;
    /** Input instruction text */
    helpText?: string;
    /** Text to be displayed on error */
    errorMessage?: string;
    /** Element to be displayed along with label */
    labelAddOn?: () => JSX.Element;
    /** Whether this field is required to submit form, adds red required asterisk */
    required?: boolean;
    /** Useful for associating a label with an input */
    htmlFor?: string;
    /** ID for Error Message for Integration Tests */
    errorMessageTestId?: string;
}
type FormElementRef = HTMLLabelElement & HTMLDivElement;
declare const FormElement: React.ForwardRefExoticComponent<FormElementProps & React.RefAttributes<FormElementRef>>;
interface FormElementErrorProps extends StandardFunctionProps {
    /** Text to be displayed on error */
    message?: string;
}
type FormElementErrorRef = HTMLSpanElement;
declare const FormElementError: React.ForwardRefExoticComponent<FormElementErrorProps & React.RefAttributes<HTMLSpanElement>>;
interface FormFooterProps extends StandardFunctionProps {
}
type FormFooterRef = HTMLDivElement;
declare const FormFooter: React.ForwardRefExoticComponent<FormFooterProps & React.RefAttributes<HTMLDivElement>>;
interface FormHelpTextProps extends StandardFunctionProps {
    /** Input discription  or instruction text */
    text: string;
}
type FormHelpTextRef = HTMLSpanElement;
declare const FormHelpText: React.ForwardRefExoticComponent<FormHelpTextProps & React.RefAttributes<HTMLSpanElement>>;
interface FormLabelProps extends StandardFunctionProps {
    /** Label Text */
    label: string;
    /** Whether this field is required to submit form, adds red required asterisk */
    required?: boolean;
    /** Useful for associating a label with an input */
    htmlFor?: string;
}
type FormLabelRef = HTMLDivElement & HTMLLabelElement;
declare const FormLabel: React.ForwardRefExoticComponent<FormLabelProps & React.RefAttributes<FormLabelRef>>;
interface FormValidationElementProps extends StandardFunctionProps {
    /** Child components */
    children: (status: ComponentStatus) => React.ReactNode;
    /** Function used for validation check */
    validationFunc: ValidationFunction;
    /** Function called when validation status */
    onStatusChange?: (newStatus: ComponentStatus) => void;
    /** Element to be displayed along with label */
    labelAddOn?: () => JSX.Element;
    /** Label Text */
    label: string;
    /** Field value */
    value: string;
    /** Input instruction text */
    helpText?: string;
    /** Whether this field is required to submit form, adds red required asterisk */
    required?: boolean;
    /** Useful for associating a label with an input */
    htmlFor?: string;
    /** Pre-validation mode ( Validation happens ) */
    prevalidate?: boolean;
}
type FormValidationElementRef = HTMLLabelElement;
declare const FormValidationElement: React.ForwardRefExoticComponent<FormValidationElementProps & React.RefAttributes<HTMLLabelElement>>;
declare class Form extends Component<FormProps> {
    static readonly displayName = "Form";
    static Form: React.ForwardRefExoticComponent<FormProps & React.RefAttributes<HTMLFormElement>>;
    static Box: React.ForwardRefExoticComponent<FormBoxProps & React.RefAttributes<HTMLDivElement>>;
    static Divider: React.ForwardRefExoticComponent<FormDividerProps & React.RefAttributes<HTMLDivElement>>;
    static Element: React.ForwardRefExoticComponent<FormElementProps & React.RefAttributes<FormElementRef>>;
    static ElementError: React.ForwardRefExoticComponent<FormElementErrorProps & React.RefAttributes<HTMLSpanElement>>;
    static Footer: React.ForwardRefExoticComponent<FormFooterProps & React.RefAttributes<HTMLDivElement>>;
    static HelpText: React.ForwardRefExoticComponent<FormHelpTextProps & React.RefAttributes<HTMLSpanElement>>;
    static Label: React.ForwardRefExoticComponent<FormLabelProps & React.RefAttributes<FormLabelRef>>;
    static ValidationElement: React.ForwardRefExoticComponent<FormValidationElementProps & React.RefAttributes<HTMLLabelElement>>;
    render(): JSX.Element;
}
interface GridProps extends StandardFunctionProps {
}
type GridRef = HTMLDivElement;
interface GridColumnProps extends StandardFunctionProps {
    /** Number of columns spanned when viewport width is less than 750px */
    widthXS?: Columns;
    /** Number of columns spanned when viewport width is greater than 750px */
    widthSM?: Columns;
    /** Number of columns spanned when viewport width is greater than 1080px */
    widthMD?: Columns;
    /** Number of columns spanned when viewport width is greater than 1500px */
    widthLG?: Columns;
    /** Number of columns shifted when viewport width is less than 750px */
    offsetXS?: Columns;
    /** Number of columns shifted when viewport width is greater than 750px */
    offsetSM?: Columns;
    /** Number of columns shifted when viewport width is greater than 1080px */
    offsetMD?: Columns;
    /** Number of columns shifted when viewport width is greater than 1500px */
    offsetLG?: Columns;
}
type GridColumnRef = HTMLDivElement;
declare const GridColumn: React.ForwardRefExoticComponent<GridColumnProps & React.RefAttributes<HTMLDivElement>>;
interface GridRowProps extends StandardFunctionProps {
}
type GridRowRef = HTMLDivElement;
declare const GridRow: React.ForwardRefExoticComponent<GridRowProps & React.RefAttributes<HTMLDivElement>>;
declare class Grid extends Component<GridProps> {
    static readonly displayName = "Grid";
    static Grid: React.ForwardRefExoticComponent<GridProps & React.RefAttributes<HTMLDivElement>>;
    static Column: React.ForwardRefExoticComponent<GridColumnProps & React.RefAttributes<HTMLDivElement>>;
    static Row: React.ForwardRefExoticComponent<GridRowProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface IconProps extends StandardFunctionProps {
    /** Icon to display */
    glyph: IconFont | string;
}
type IconRef = HTMLSpanElement;
declare const Icon: React.ForwardRefExoticComponent<IconProps & React.RefAttributes<HTMLSpanElement>>;
interface BulletProps extends StandardFunctionProps {
    /** Icon to display */
    glyph?: IconFont | string;
    /** Text to display */
    text?: string | number;
    /** Coloration of bullet circle */
    backgroundColor?: InfluxColors | string;
    /** Coloration of bullet text or icon */
    color?: InfluxColors | string;
    /** Size of bullet */
    size?: ComponentSize;
}
type BulletRef = HTMLSpanElement;
declare const Bullet: React.ForwardRefExoticComponent<BulletProps & React.RefAttributes<HTMLSpanElement>>;
interface IndexListProps extends StandardFunctionProps {
}
type IndexListRef = HTMLTableElement;
interface IndexListBodyProps extends StandardFunctionProps {
    /** Rendered when no children are passed in */
    emptyState: JSX.Element;
    /** Used to ensure the empty state takes up the full width of the table */
    columnCount: number;
}
type IndexListBodyRef = HTMLTableSectionElement;
declare const IndexListBody: React.ForwardRefExoticComponent<IndexListBodyProps & React.RefAttributes<HTMLTableSectionElement>>;
interface IndexListHeaderProps extends StandardFunctionProps {
}
type IndexListHeaderRef = HTMLTableSectionElement;
declare const IndexListHeader: React.ForwardRefExoticComponent<IndexListHeaderProps & React.RefAttributes<HTMLTableSectionElement>>;
interface IndexListHeaderCellProps extends StandardFunctionProps {
    /** Can be a % or px */
    width: string;
    /** Text to display as column header */
    columnName?: string;
    /** Text alignment of column header */
    alignment?: Alignment;
    /** Controls appearance of sort indicator (arrow) */
    sort?: Sort;
    /** Unique identifier for use in managing sort state */
    sortKey?: string;
    /** Useful for triggering a change in sort state */
    onClick?: (nextSort: Sort, sortKey: string | undefined) => void;
}
type IndexListHeaderCellRef = HTMLTableHeaderCellElement;
declare const IndexListHeaderCell: React.ForwardRefExoticComponent<IndexListHeaderCellProps & React.RefAttributes<HTMLTableHeaderCellElement>>;
interface IndexListRowProps extends StandardFunctionProps {
    /** Renders the row with disabled styles */
    disabled?: boolean;
    /** Brightens the row so it can contrast with components such as Panel or Tabs */
    brighten?: boolean;
}
type IndexListRowRef = HTMLTableRowElement;
declare const IndexListRow: React.ForwardRefExoticComponent<IndexListRowProps & React.RefAttributes<HTMLTableRowElement>>;
interface IndexListRowCellProps extends StandardFunctionProps {
    /** Text alignment of contents */
    alignment?: Alignment;
    /** If true the contents of this cell will be hidden until the containing row is hovered */
    revealOnHover?: boolean;
}
type IndexListRowCellRef = HTMLTableDataCellElement;
declare const IndexListRowCell: React.ForwardRefExoticComponent<IndexListRowCellProps & React.RefAttributes<HTMLTableDataCellElement>>;
declare class IndexList extends Component<IndexListProps> {
    static readonly displayName = "IndexList";
    static IndexList: React.ForwardRefExoticComponent<IndexListProps & React.RefAttributes<HTMLTableElement>>;
    static Body: React.ForwardRefExoticComponent<IndexListBodyProps & React.RefAttributes<HTMLTableSectionElement>>;
    static Header: React.ForwardRefExoticComponent<IndexListHeaderProps & React.RefAttributes<HTMLTableSectionElement>>;
    static HeaderCell: React.ForwardRefExoticComponent<IndexListHeaderCellProps & React.RefAttributes<HTMLTableHeaderCellElement>>;
    static Row: React.ForwardRefExoticComponent<IndexListRowProps & React.RefAttributes<HTMLTableRowElement>>;
    static Cell: React.ForwardRefExoticComponent<IndexListRowCellProps & React.RefAttributes<HTMLTableDataCellElement>>;
    render(): JSX.Element;
}
interface InputProps extends StandardFunctionProps {
    /** Minimum value for number & range types */
    min?: number;
    /** Maximum value for number & range types */
    max?: number;
    /** Stepping interval granularity for range type */
    step?: number;
    /** Determines whether checkbox is checked */
    checked?: boolean;
    /** Function to be called on field value change */
    onChange?: (e: ChangeEvent<HTMLInputElement>) => void;
    /** Function to be called on focus loss */
    onBlur?: (e?: ChangeEvent<HTMLInputElement>) => void;
    /** Function to be called on focus gain */
    onFocus?: (e?: ChangeEvent<HTMLInputElement>) => void;
    /** Function to be called on key press */
    onKeyPress?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Function to be called on key up */
    onKeyUp?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Function to be called on key down */
    onKeyDown?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Icon to be displayed to the left of text */
    icon?: IconFont;
    /** Maximum string length for input value */
    maxLength?: number;
    /** Keyboard control tab order  */
    tabIndex?: number;
    /** Input type (text, number, password, email, checkbox)  */
    type?: InputType;
    /** Input field name attribute */
    name?: string;
    /** Input field value to be updated with 'on X' functions */
    value?: string | number;
    /** Placeholder text when no value is present */
    placeholder?: string;
    /** Allows or disallows browser autocomplete functionality */
    autocomplete?: AutoComplete;
    /** Text to be displayed on hover tooltip */
    titleText?: string;
    /** Text to be displayed on hover tooltip when radio button is disabled */
    disabledTitleText?: string;
    /** Input Component size */
    size?: ComponentSize;
    /** Input status state */
    status?: ComponentStatus;
    /** Whether or not the input receives autofocus when mounted */
    autoFocus?: boolean;
    /** Allows or disallows browser spellcheck functionality */
    spellCheck?: boolean;
    /** CSS attributes for the input element */
    inputStyle?: CSSProperties;
    /** For use within a form, marks the input as required */
    required?: boolean;
    /** Pass in a RegEx matcher for best results */
    pattern?: string;
    /** Pass through for container ref */
    containerRef?: RefObject<InputContainerRef>;
    /** Render input using monospace font */
    monospace?: boolean;
}
type InputRef = HTMLInputElement;
type InputContainerRef = HTMLDivElement;
declare const Input: React.ForwardRefExoticComponent<InputProps & React.RefAttributes<HTMLInputElement>>;
interface InputLabelProps extends StandardFunctionProps {
    /** Used to match the state of the associated SlideToggle */
    active?: boolean;
    /** Button size */
    size?: ComponentSize;
    /** Controls text wrapping */
    wrapText?: boolean;
    /** Associate this label with a specific input */
    htmlFor?: string;
    /** Keyboard control tab order  */
    tabIndex?: number;
}
type InputLabelRef = HTMLLabelElement;
declare const InputLabel: React.ForwardRefExoticComponent<InputLabelProps & React.RefAttributes<HTMLLabelElement>>;
interface TextAreaProps extends StandardFunctionProps {
    /** TextArea Component size */
    size?: ComponentSize;
    /** TextArea status state */
    status?: ComponentStatus;
    /** Function to be called on field value change */
    onChange?: (e: ChangeEvent<HTMLTextAreaElement>) => void;
    /** Function to be called on focus loss */
    onBlur?: (e?: ChangeEvent<HTMLTextAreaElement>) => void;
    /** Function to be called on focus gain */
    onFocus?: (e?: ChangeEvent<HTMLTextAreaElement>) => void;
    /** Function to be called on key press */
    onKeyPress?: (e: KeyboardEvent<HTMLTextAreaElement>) => void;
    /** Function to be called on key up */
    onKeyUp?: (e: KeyboardEvent<HTMLTextAreaElement>) => void;
    /** Function to be called on key down */
    onKeyDown?: (e: KeyboardEvent<HTMLTextAreaElement>) => void;
    /** Allows or disallows browser autocomplete functionality */
    autocomplete?: AutoComplete;
    /** Whether or not the input receives autofocus when mounted */
    autoFocus?: boolean;
    /** Associates the text area with a form even if outside the form */
    form?: string;
    /** Maximum string length for input value */
    maxLength?: number;
    /** Minimum string length for input value */
    minLength?: number;
    /** TextArea field name attribute */
    name?: string;
    /** Placeholder text when no value is present */
    placeholder?: string;
    /** Toggles read-only state of text area */
    readOnly?: boolean;
    /** Specified text area as a required field */
    required?: boolean;
    /** Sets width in columns */
    cols?: number;
    /** sets height in rows */
    rows?: number;
    /** Allows or disallows browser spellcheck functionality */
    spellCheck?: boolean;
    /** Sets text wrap */
    wrap?: Wrap;
    /** TextArea field value to be updated with 'on X' functions */
    value?: string;
    /** Container ref */
    containerRef?: RefObject<TextAreaContainerRef>;
    /** Use a monospace font */
    monospace?: boolean;
}
type TextAreaRef = HTMLTextAreaElement;
type TextAreaContainerRef = HTMLDivElement;
declare const TextArea: React.ForwardRefExoticComponent<TextAreaProps & React.RefAttributes<HTMLTextAreaElement>>;
/**
 *  To have a clickable label (clicking on the label clicks/unclicks the toggle) add a 'htmlFor'
 *  property to the label that matches the buttonId.
 *
 *  for example:
 *
 *    <Toggle
 *       tabIndex={2}
 *       value="vertical"
 *       id="vertical-legend-orientation"
 *       name="lengendOr"
 *       checked={legendOrientation === LEGEND_ORIENTATION_THRESHOLD_VERTICAL}
 *       onChange={() =>
 *                handleSetOrientation(LEGEND_ORIENTATION_THRESHOLD_VERTICAL)
 *              }
 *       type={InputToggleType.Radio}
 *       size={ComponentSize.ExtraSmall}
 *       color={ComponentColor.Primary}
 *       appearance={Appearance.Outline}
 *       >
 *       <InputLabel
 *            active={legendOrientation === LEGEND_ORIENTATION_THRESHOLD_VERTICAL}
 *            htmlFor="vertical-legend-orientation"
 *         >
 *           Vertical
 *      </InputLabel>
 *  </Toggle>
 *
 * and all radiobuttons in the same group should have the same name, as well.
 *
 *
 * */
interface ToggleProps extends Omit<StandardFunctionProps, "id"> {
    /** Unique identifier for this toggle */
    id: string;
    /** Determines whether checkbox is checked */
    checked?: boolean;
    /** Choose either "Radio" or "Checkbox" */
    type: InputToggleType;
    /** Function to be called on change */
    onChange: (value?: string) => void;
    /** Function to be called on focus loss */
    onBlur?: (e?: ChangeEvent<HTMLLabelElement>) => void;
    /** Function to be called on focus gain */
    onFocus?: (e?: ChangeEvent<HTMLLabelElement>) => void;
    /** Function to be called on key press */
    onKeyPress?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Function to be called on key up */
    onKeyUp?: (e: KeyboardEvent<HTMLLabelElement>) => void;
    /** Function to be called on key down */
    onKeyDown?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Icon to be displayed to the left of text */
    icon?: IconFont;
    /** Keyboard control tab order  */
    tabIndex?: number;
    /** Used to group toggles together in a form */
    name?: string;
    /** Togle field value to be updated with 'on X' functions */
    value?: string;
    /** Text to be displayed on hover tooltip */
    titleText?: string;
    /** Text to be displayed on hover tooltip when radio button is disabled */
    disabledTitleText?: string;
    /** Toggle Component size */
    size?: ComponentSize;
    /** Prevents the user from interacting with this component */
    disabled?: boolean;
    /** Whether or not the input receives autofocus when mounted */
    autoFocus?: boolean;
    /** Refers to the visible element rather than the hidden input that ref refers to */
    containerRef?: RefObject<ToggleContainerRef>;
    /** Controls color of toggle */
    color?: ComponentColor;
    /** Renders the toggle as either "Solid" or "Outline" */
    appearance?: Appearance;
}
type ToggleRef = HTMLInputElement;
type ToggleContainerRef = HTMLDivElement;
declare const Toggle: React.ForwardRefExoticComponent<ToggleProps & React.RefAttributes<HTMLInputElement>>;
interface SelectGroupProps extends StandardFunctionProps {
    /** SelectGroup color */
    color?: ComponentColor;
    /** SelectGroup size */
    size?: ComponentSize;
    /** Shape... */
    shape?: ButtonShape;
}
type SelectGroupRef = HTMLDivElement;
interface SelectGroupOptionProps extends Omit<StandardFunctionProps, "id"> {
    /** Unique identifier for this radio button */
    id: string;
    /** Toggles radio button active state */
    active: boolean;
    /** Input value of the selected radio button */
    value: any;
    /** Keyboard control tab order  */
    tabIndex?: number;
    /** Used to group toggles together in a form */
    name?: string;
    /** Function to be called on radio button click */
    onClick: (value: any) => void;
    /** Function to be called on key up */
    onKeyUp?: (e: KeyboardEvent<HTMLLabelElement>) => void;
    /** Text to be displayed on hover tooltip */
    titleText?: string;
    /** Prevents the user from interacting with this component */
    disabled?: boolean;
    /** Text to be displayed on hover tooltip when radio button is disabled */
    disabledTitleText?: string;
    /** Choose either "SelectGroup" or "Checkbox" */
    type?: InputToggleType;
    /** Refers to the visible element rather than the hidden input that ref refers to */
    containerRef?: RefObject<SelectGroupOptionContainerRef>;
}
type SelectGroupOptionRef = HTMLInputElement;
type SelectGroupOptionContainerRef = HTMLLabelElement;
declare const SelectGroupOption: React.ForwardRefExoticComponent<SelectGroupOptionProps & React.RefAttributes<HTMLInputElement>>;
declare class SelectGroup extends Component<SelectGroupProps> {
    static readonly displayName = "SelectGroup";
    static SelectGroup: React.ForwardRefExoticComponent<SelectGroupProps & React.RefAttributes<HTMLDivElement>>;
    static Option: React.ForwardRefExoticComponent<SelectGroupOptionProps & React.RefAttributes<HTMLInputElement>>;
    render(): JSX.Element;
}
interface AutoInputProps extends StandardFunctionProps {
    /** Pass in a component of type "Input" */
    inputComponent: JSX.Element;
    /** Fires when the radio is toggled and the mode changes */
    onChangeMode: (mode: AutoInputMode) => void;
    /** Modality of radio, either "Auto" or "Custom" */
    mode: AutoInputMode;
    /** SelectGroup color */
    color?: ComponentColor;
    /** Controls size of SelectGroup & Input sub-components */
    size?: ComponentSize;
    /** Pass through ref for SelectGroup */
    radioRef?: RefObject<SelectGroupRef>;
    /** Pass through ref for "Auto" SelectGroupOption */
    radioButtonAutoRef?: RefObject<SelectGroupOptionRef>;
    /** Pass through ref for "Custom" SelectGroupOption */
    radioButtonCustomRef?: RefObject<SelectGroupOptionRef>;
}
type AutoInputRef = HTMLDivElement;
declare const AutoInput: React.ForwardRefExoticComponent<AutoInputProps & React.RefAttributes<HTMLDivElement>>;
interface RangeSliderProps extends StandardFunctionProps {
    /** Minimum value */
    min: number;
    /** Maximum value */
    max: number;
    /** Stepping interval granularity for range type */
    step?: number;
    /** Input field value to be updated with 'on X' functions */
    value: number;
    /** Function to be called on field value change */
    onChange: (e: ChangeEvent<HTMLInputElement>) => void;
    /** Allows or disallows browser autocomplete functionality */
    autocomplete?: AutoComplete;
    /** Input status state */
    status?: ComponentStatus;
    /** Size of handle and track  */
    size?: ComponentSize;
    /** Color of slider handle */
    color?: ComponentColor;
    /** Fill the track before the handle to indicate percentage */
    fill?: boolean;
    /** Displays the min and max values below the slider */
    hideLabels?: boolean;
    /** Adds a prefix to labels */
    labelPrefix?: string;
    /** Adds a suffix to labels */
    labelSuffix?: string;
    /** Determines orientation of range slider */
    orientation?: ComponentOrientation;
    /** Determines whether to display value  */
    displayValue?: boolean;
}
type RangeSliderRef = HTMLInputElement;
declare const RangeSlider: React.ForwardRefExoticComponent<RangeSliderProps & React.RefAttributes<HTMLInputElement>>;
interface VisibilityInputProps extends StandardFunctionProps {
    /** Function to be called on field value change */
    onChange?: (e: ChangeEvent<HTMLInputElement>) => void;
    /** Function to be called on focus loss */
    onBlur?: (e?: ChangeEvent<HTMLInputElement>) => void;
    /** Function to be called on focus gain */
    onFocus?: (e?: ChangeEvent<HTMLInputElement>) => void;
    /** Function to be called on key press */
    onKeyPress?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Function to be called on key up */
    onKeyUp?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Function to be called on key down */
    onKeyDown?: (e: KeyboardEvent<HTMLInputElement>) => void;
    /** Icon to be displayed to the left of text */
    icon?: IconFont;
    /** Maximum string length for input value */
    maxLength?: number;
    /** Keyboard control tab order  */
    tabIndex?: number;
    /** Input field name attribute */
    name?: string;
    /** Input field value to be updated with 'on X' functions */
    value?: string;
    /** Placeholder text when no value is present */
    placeholder?: string;
    /** Allows or disallows browser autocomplete functionality */
    autocomplete?: AutoComplete;
    /** Text to be displayed on hover tooltip */
    titleText?: string;
    /** Text to be displayed on hover tooltip when radio button is disabled */
    disabledTitleText?: string;
    /** Input Component size */
    size?: ComponentSize;
    /** Input status state */
    status?: ComponentStatus;
    /** Whether or not the input receives autofocus when mounted */
    autoFocus?: boolean;
    /** Allows or disallows browser spellcheck functionality */
    spellCheck?: boolean;
    /** For use within a form, marks the input as required */
    required?: boolean;
    /** Pass in a RegEx matcher for best results */
    pattern?: string;
    /** Toggle Visibility of text */
    visible?: boolean;
    /** Function to be called on button click */
    onToggleClick?: (e?: MouseEvent<HTMLButtonElement>) => void;
}
type VisibilityInputRef = HTMLInputElement;
declare const VisibilityInput: React.ForwardRefExoticComponent<VisibilityInputProps & React.RefAttributes<HTMLInputElement>>;
type TimeInputRef = InputRef;
interface TimeInputProps extends Omit<InputProps, "type" | "checked" | "spellCheck" | "step" | "min" | "max" | "pattern" | "onChange" | "autocomplete" | "monospace"> {
    /** Callback for input changes */
    onChange: (value: string, e?: ChangeEvent<TimeInputRef>) => void;
    /** Currently selected unit */
    selectedUnit: string;
    /** Available units (in Dropdown) */
    units?: string[];
    /** Callback for when time unit is changed */
    onSelectUnit: (unit: string) => void;
}
declare const TimeInput: React.ForwardRefExoticComponent<TimeInputProps & React.RefAttributes<HTMLInputElement>>;
interface LabelProps extends StandardFunctionProps {
    /** Unique value to be returned when Label is clicked */
    id: string;
    /** Name of the Label, appears inside the label */
    name: string;
    /** Description of Label, appears on hover */
    description: string;
    /** Used to colorize the label, can be hexcode or rgba */
    color: InfluxColors | string;
    /** Optional click handler */
    onClick?: (id: string) => void;
    /** Optional delete handler, if passed in the delete button is rendered */
    onDelete?: (id: string) => void;
    /** Size of Label */
    size?: ComponentSize;
}
type LabelRef = HTMLDivElement;
declare const Label: React.ForwardRefExoticComponent<LabelProps & React.RefAttributes<HTMLDivElement>>;
type NavMenuProps = StandardFunctionProps;
type NavMenuRef = HTMLElement;
interface NavMenuItemProps extends StandardFunctionProps {
    /** Render prop for linked title text */
    titleLink: RenderLinkElement;
    /** Render prop for linked icon component */
    iconLink: RenderLinkElement;
    /** Controls highlighting of the menu item */
    active: boolean;
}
type NavMenuItemRef = HTMLDivElement;
declare const NavMenuItem: React.ForwardRefExoticComponent<NavMenuItemProps & React.RefAttributes<HTMLDivElement>>;
interface NavMenuSubItemProps extends StandardFunctionProps {
    /** Controls highlighting of the menu item */
    active: boolean;
    /** Render prop for linked title text (suggested <a /> or <Link /> ) */
    titleLink: (className: string, testID?: string, style?: CSSProperties) => JSX.Element;
}
declare const NavMenuSubItem: FunctionComponent<NavMenuSubItemProps>;
declare class NavMenu extends Component<NavMenuProps> {
    static readonly displayName = "NavMenu";
    static NavMenu: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLElement>>;
    static Item: React.ForwardRefExoticComponent<NavMenuItemProps & React.RefAttributes<HTMLDivElement>>;
    static SubItem: React.FunctionComponent<NavMenuSubItemProps>;
    render(): JSX.Element;
}
interface NotificationDialogProps extends StandardFunctionProps {
    /** Icon to display before notification content */
    icon?: IconFont;
    /** Controls if the notification is showing or hidden */
    visible?: boolean;
    /** Optional gradient theme of panel, supercedes backgroundColor prop */
    gradient?: Gradients;
    /** Notification color */
    backgroundColor?: InfluxColors | string;
    /** If a function is passed in a dismiss button will appear on the notification */
    onDismiss?: (id?: string) => void;
    /** Controls padding and font size of the notification */
    size: ComponentSize;
}
type NotificationDialogRef = HTMLDivElement;
declare const NotificationDialog: React.ForwardRefExoticComponent<NotificationDialogProps & React.RefAttributes<HTMLDivElement>>;
interface NotificationProps extends NotificationDialogProps {
    /** Positioning the notification left, center, or right on the window */
    horizontalAlignment?: Alignment;
    /** Positioning the notification top, middle, or bottom on the window */
    verticalAlignment?: VerticalAlignment;
    /** If a function is passed in a dismiss button will appear on the notification */
    onDismiss?: (id?: string) => void;
    /** Function called when duration expires */
    onTimeout?: (id?: string) => void;
    /** Duration before notification calls onTimeout function */
    duration?: number;
}
type NotificationRef = NotificationDialogRef;
declare class Notification extends Component<NotificationProps> {
    static readonly displayName = "Notification";
    static Notification: React.ForwardRefExoticComponent<NotificationProps & React.RefAttributes<HTMLDivElement>>;
    static Dialog: React.ForwardRefExoticComponent<NotificationDialogProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface OverlayProps extends StandardFunctionProps {
    /** Controls visibility of the overlay */
    visible: boolean;
    /** Will replace the mask element with a custom element, useful for customizing the mask appearance */
    renderMaskElement?: (style: CSSProperties) => JSX.Element;
    /** Controls the transition timing */
    transitionDuration?: number;
    /** Accepts state handler for visible prop to enable escape press functionality */
    onEscape?: (visible: boolean) => void;
}
interface OverlayContainerProps extends StandardFunctionProps {
    /** Pixel width maximum for overlay */
    maxWidth?: number;
    /** Margins on all sides of overlay */
    margin?: ComponentSize;
}
type OverlayContainerRef = HTMLDivElement;
declare const OverlayContainer: React.ForwardRefExoticComponent<OverlayContainerProps & React.RefAttributes<HTMLDivElement>>;
interface OverlayHeaderProps extends StandardFunctionProps {
    /** Title of the Overlay */
    title: string;
    /** Passing a function into this prop will cause the Dismiss "X" to render in the header */
    onDismiss?: () => void;
    /** Wrap text */
    wrapText?: boolean;
}
type OverlayHeaderRef = HTMLDivElement;
declare const OverlayHeader: React.ForwardRefExoticComponent<OverlayHeaderProps & React.RefAttributes<HTMLDivElement>>;
interface OverlayMaskProps extends StandardFunctionProps {
    /** Optional gradient theme of panel*/
    gradient?: Gradients;
    /** Optional background color of panel, supercedes gradient prop  */
    backgroundColor?: InfluxColors | string;
}
type OverlayMaskRef = HTMLDivElement;
declare const OverlayMask: React.ForwardRefExoticComponent<OverlayMaskProps & React.RefAttributes<HTMLDivElement>>;
interface OverlayBodyProps extends StandardFunctionProps {
}
type OverlayBodyRef = HTMLDivElement;
declare const OverlayBody: React.ForwardRefExoticComponent<OverlayBodyProps & React.RefAttributes<HTMLDivElement>>;
interface OverlayFooterProps extends StandardFunctionProps {
}
type OverlayFooterRef = HTMLDivElement;
declare const OverlayFooter: React.ForwardRefExoticComponent<OverlayFooterProps & React.RefAttributes<HTMLDivElement>>;
declare class Overlay extends Component<OverlayProps> {
    static readonly displayName = "Overlay";
    static Overlay: React.FunctionComponent<OverlayProps>;
    static Container: React.ForwardRefExoticComponent<OverlayContainerProps & React.RefAttributes<HTMLDivElement>>;
    static Header: React.ForwardRefExoticComponent<OverlayHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static Mask: React.ForwardRefExoticComponent<OverlayMaskProps & React.RefAttributes<HTMLDivElement>>;
    static Body: React.ForwardRefExoticComponent<OverlayBodyProps & React.RefAttributes<HTMLDivElement>>;
    static Footer: React.ForwardRefExoticComponent<OverlayFooterProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
type ListItemRef = HTMLDivElement;
interface ListProps extends StandardFunctionProps {
    /** Disable scrolling horizontally */
    noScrollX?: boolean;
    /** Disable scrolling vertically */
    noScrollY?: boolean;
    /** Automatically scroll to selected item when dropdown is opened */
    scrollToSelected?: boolean;
    /** Pass through ref for contents element within scrollbars */
    contentsRef?: RefObject<ListContentsRef>;
    /** Useful for customizing appearance of the contents element within scrollbars */
    contentsStyle?: CSSProperties;
    /** Controls autoHide behavior of scrollbars within the menu */
    autoHideScrollbars?: boolean;
    /** Gradient start color */
    thumbStartColor?: string | InfluxColors;
    /** Gradient end color */
    thumbStopColor?: string | InfluxColors;
    /** Colorizes the background of the list */
    backgroundColor?: InfluxColors | string;
    /** Overrides backgroundColor, fills background with gradient */
    gradient?: Gradients;
    /** Pixel height after which the list will scroll */
    maxHeight?: string;
}
type ListRef = HTMLDivElement;
type ListContentsRef = HTMLDivElement;
interface ListItemSharedProps {
    /** Whether or not the item should have selected styling */
    selected?: boolean;
    /** Size of this component */
    size?: ComponentSize;
}
interface ListItemContextProps extends ListItemSharedProps {
    listItemContrastColor?: string;
    listItemBackgroundColor?: InfluxColors | string;
    listItemGradient?: Gradients;
}
type CombinedListItemProps = ListItemSharedProps & StandardFunctionProps;
interface ListItemProps extends CombinedListItemProps {
    /** Value to be returned via the onClick function */
    value?: any;
    /** When a dropdown item is clicked, its `value` prop is returned via `onChange` */
    onClick?: (value?: any, e?: MouseEvent<ListItemRef>) => void;
    /** Controls whether the text contents of this item wrap or not */
    wrapText?: boolean;
    /** Title attribute */
    title?: string;
    /** Prevents any interaction with this element, including the onClick function */
    disabled?: boolean;
    /** Pass in an <a> or <Link> element as an alternative to onClick */
    linkElement?: JSX.Element;
    /** Colorizes the background of the list item in hover and selected state */
    backgroundColor?: InfluxColors | string;
    /** Overrides backgroundColor, fills background with gradient */
    gradient?: Gradients;
}
type ListItemRef$0 = HTMLDivElement;
declare const ListItemContext: React.Context<ListItemContextProps>;
declare const ListItem: React.ForwardRefExoticComponent<ListItemProps & React.RefAttributes<HTMLDivElement>>;
interface ListEmptyStateProps extends StandardFunctionProps {
    /** Controls whether the text contents of this item wrap or not */
    wrapText?: boolean;
    /** Size of this component */
    size?: ComponentSize;
}
type ListEmptyStateRef = HTMLDivElement;
declare const ListEmptyState: React.ForwardRefExoticComponent<ListEmptyStateProps & React.RefAttributes<HTMLDivElement>>;
interface ListDividerProps extends StandardFunctionProps {
    /** Text to be displayed on divider, a line will be displayed if no text is provided */
    text?: string;
    /** Size of this component */
    size?: ComponentSize;
}
type ListDividerRef = HTMLDivElement;
declare const ListDivider: React.ForwardRefExoticComponent<ListDividerProps & React.RefAttributes<HTMLDivElement>>;
type ListIndicatorType = "checkbox" | "dot";
interface ListIndicatorProps {
    /** Controls appearance of indicator */
    type: ListIndicatorType;
}
declare const ListIndicator: FunctionComponent<ListIndicatorProps>;
interface ListIconProps {
    /** Icon to display */
    glyph: IconFont | string;
}
declare const ListIcon: FunctionComponent<ListIconProps>;
declare class List extends Component<ListProps> {
    static readonly displayName = "List";
    static List: React.ForwardRefExoticComponent<ListProps & React.RefAttributes<HTMLDivElement>>;
    static Item: React.ForwardRefExoticComponent<ListItemProps & React.RefAttributes<HTMLDivElement>>;
    static EmptyState: React.ForwardRefExoticComponent<ListEmptyStateProps & React.RefAttributes<HTMLDivElement>>;
    static Divider: React.ForwardRefExoticComponent<ListDividerProps & React.RefAttributes<HTMLDivElement>>;
    static Indicator: React.FunctionComponent<ListIndicatorProps>;
    static Icon: React.FunctionComponent<ListIconProps>;
    render(): JSX.Element;
}
interface InfluxDataLogoProps extends StandardFunctionProps {
    /** Coloration of the SVG image */
    fill?: InfluxColors | string;
}
type InfluxDataLogoRef = SVGSVGElement;
declare const InfluxDataLogo: React.ForwardRefExoticComponent<InfluxDataLogoProps & React.RefAttributes<SVGSVGElement>>;
interface InfluxDBCloudLogoProps extends StandardFunctionProps {
    /** Coloration of the SVG image */
    fill?: InfluxColors | string;
    /** Controls rendering of optional "cloud" suffix */
    cloud: boolean;
}
type InfluxDBCloudLogoRef = SVGSVGElement;
declare const InfluxDBCloudLogo: React.ForwardRefExoticComponent<InfluxDBCloudLogoProps & React.RefAttributes<SVGSVGElement>>;
interface PageProps extends StandardFunctionProps {
    /** Use this prop to update document.title when the page first renders &  on subsequent updates */
    titleTag?: string;
}
type PageRef = HTMLDivElement;
interface PageHeaderProps extends StandardFunctionProps {
    /** Allows the control bar to fill the width of the screen */
    fullWidth: boolean;
    /** Controls the gutters (left and right margins) */
    gutters?: ComponentSize;
}
type PageHeaderRef = HTMLDivElement;
declare const PageHeader: React.ForwardRefExoticComponent<PageHeaderProps & React.RefAttributes<HTMLDivElement>>;
interface PageTitleProps extends StandardFunctionProps {
    /** Text to display in title */
    title: string;
    /** Alternate text for screen readers */
    altText?: string;
}
type PageTitleRef = HTMLHeadingElement;
declare const PageTitle: React.ForwardRefExoticComponent<PageTitleProps & React.RefAttributes<HTMLHeadingElement>>;
interface PageControlBarProps extends StandardFunctionProps {
    /** Allows the control bar to fill the width of the screen */
    fullWidth: boolean;
    /** Controls the gutters (left and right margins) */
    gutters?: ComponentSize;
}
type PageControlBarRef = HTMLDivElement;
declare const PageControlBar: React.ForwardRefExoticComponent<PageControlBarProps & React.RefAttributes<HTMLDivElement>>;
interface PageControlBarLeftProps extends StandardFunctionProps {
}
type PageControlBarLeftRef = HTMLDivElement;
declare const PageControlBarLeft: React.ForwardRefExoticComponent<PageControlBarLeftProps & React.RefAttributes<HTMLDivElement>>;
interface PageControlBarCenterProps extends StandardFunctionProps {
}
type PageControlBarCenterRef = HTMLDivElement;
declare const PageControlBarCenter: React.ForwardRefExoticComponent<PageControlBarCenterProps & React.RefAttributes<HTMLDivElement>>;
interface PageControlBarRightProps extends StandardFunctionProps {
}
type PageControlBarRightRef = HTMLDivElement;
declare const PageControlBarRight: React.ForwardRefExoticComponent<PageControlBarRightProps & React.RefAttributes<HTMLDivElement>>;
interface PageContentsProps extends StandardFunctionProps {
    /** Allows the page contents to fill the width of the screen */
    fullWidth?: boolean;
    /** Allows contents to scroll on overflow */
    scrollable?: boolean;
    /** If scrollable is true, this toggles whether the scrollbar is always visible */
    autoHideScrollbar?: boolean;
    /** Controls the gutters (left and right margins) */
    gutters?: ComponentSize;
}
type PageContentsRef = HTMLDivElement;
declare const PageContents: React.ForwardRefExoticComponent<PageContentsProps & React.RefAttributes<HTMLDivElement>>;
declare class Page extends Component<PageProps> {
    static readonly displayName = "Page";
    static Page: React.ForwardRefExoticComponent<PageProps & React.RefAttributes<HTMLDivElement>>;
    static Header: React.ForwardRefExoticComponent<PageHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static Title: React.ForwardRefExoticComponent<PageTitleProps & React.RefAttributes<HTMLHeadingElement>>;
    static ControlBar: React.ForwardRefExoticComponent<PageControlBarProps & React.RefAttributes<HTMLDivElement>>;
    static ControlBarLeft: React.ForwardRefExoticComponent<PageControlBarLeftProps & React.RefAttributes<HTMLDivElement>>;
    static ControlBarCenter: React.ForwardRefExoticComponent<PageControlBarCenterProps & React.RefAttributes<HTMLDivElement>>;
    static ControlBarRight: React.ForwardRefExoticComponent<PageControlBarRightProps & React.RefAttributes<HTMLDivElement>>;
    static Contents: React.ForwardRefExoticComponent<PageContentsProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface PaginationNavProps extends StandardFunctionProps {
    /** Total nuber of pages there exists */
    totalPages: number;
    /** currently active page */
    currentPage: number;
    /** Function to be called on page change */
    onChange: (page: number) => void;
    /** Determines how many pages are displayed within the nav.
     * For Example, pageRangeOffset =1 will result in 7 items -> {1,...,(4),5,(6),...20},
     * pageRangeOffset = 2 will result in 9 items ->  {1,...,(4,5),6,(7,8)...20},
     * pageRangeOffset = 3 will result in 11 items -> {1,...,(4,5,6),7,(8,9,10)...20} and so on
     * The compute functions will need to be refactored to provide more flexible range*/
    pageRangeOffset: number;
    hideDirectionIcon?: boolean;
    size?: ComponentSize;
}
type PaginationNavRef = HTMLElement;
declare const Pagination: React.ForwardRefExoticComponent<PaginationNavProps & React.RefAttributes<HTMLElement>>;
interface PaginationItemProps extends StandardFunctionProps {
    page?: string;
    isActive: boolean;
    onClick?: (e?: MouseEvent<HTMLElement>) => void;
    size?: ComponentSize;
}
type PaginationItemRef = HTMLLIElement;
declare const PaginationItem: React.ForwardRefExoticComponent<PaginationItemProps & React.RefAttributes<HTMLLIElement>>;
interface PaginationTruncationItemProps extends StandardFunctionProps {
    onClick?: (e?: MouseEvent<HTMLElement>) => void;
    size?: ComponentSize;
}
type PaginationTruncationItemRef = HTMLLIElement;
declare const PaginationTruncationItem: React.ForwardRefExoticComponent<PaginationTruncationItemProps & React.RefAttributes<HTMLLIElement>>;
interface PaginationDirectionItemProps extends StandardFunctionProps {
    /** Caret Left or Caret Right on button */
    direction: Direction;
    onClick?: (e?: MouseEvent<HTMLButtonElement>) => void;
    size?: ComponentSize;
    isActive: boolean;
}
type PaginationDirectionItemRef = HTMLLIElement;
declare const PaginationDirectionItem: React.ForwardRefExoticComponent<PaginationDirectionItemProps & React.RefAttributes<HTMLLIElement>>;
declare class PaginationNav extends Component<PaginationNavProps> {
    static readonly displayName = "PaginationNav";
    static PaginationNav: React.ForwardRefExoticComponent<PaginationNavProps & React.RefAttributes<HTMLElement>>;
    static Item: React.ForwardRefExoticComponent<PaginationItemProps & React.RefAttributes<HTMLLIElement>>;
    static TruncationItem: React.ForwardRefExoticComponent<PaginationTruncationItemProps & React.RefAttributes<HTMLLIElement>>;
    static DirectionItem: React.ForwardRefExoticComponent<PaginationDirectionItemProps & React.RefAttributes<HTMLLIElement>>;
    render(): JSX.Element;
}
interface PanelProps extends StandardFunctionProps {
    /** Optional gradient theme of panel, supercedes backgroundColor prop */
    gradient?: Gradients;
    /** Optional background color of panel */
    backgroundColor?: InfluxColors | string;
    /** If a function is passed in a dismiss button will appear on the Panel */
    onDismiss?: () => void;
    /** Applies to the dismiss button rendered when onDismiss is present */
    dismissButtonColor?: ComponentColor;
    /** Renders a border based on the background color or gradient */
    border?: boolean;
}
type PanelRef = HTMLDivElement;
interface PanelHeaderProps extends Omit<FlexBoxProps, "stretchToFitWidth" | "stretchToFitHeight"> {
    /** Controls padding */
    size?: ComponentSize;
}
type PanelHeaderRef = FlexBoxRef;
declare const PanelHeader: React.ForwardRefExoticComponent<PanelHeaderProps & React.RefAttributes<HTMLDivElement>>;
interface PanelSymbolHeaderProps extends PanelHeaderProps {
    /** Element to display before header text (Bullet or Icon) */
    symbol?: JSX.Element;
    /** Panel title */
    title?: JSX.Element;
}
type PanelSymbolHeaderRef = PanelHeaderRef;
declare const PanelSymbolHeader: React.ForwardRefExoticComponent<PanelSymbolHeaderProps & React.RefAttributes<HTMLDivElement>>;
interface PanelBodyProps extends Omit<FlexBoxProps, "stretchToFitWidth" | "stretchToFitHeight"> {
    /** Controls padding */
    size?: ComponentSize;
}
type PanelBodyRef = FlexBoxRef;
declare const PanelBody: React.ForwardRefExoticComponent<PanelBodyProps & React.RefAttributes<HTMLDivElement>>;
interface PanelFooterProps extends Omit<FlexBoxProps, "stretchToFitWidth" | "stretchToFitHeight"> {
    /** Controls padding */
    size?: ComponentSize;
}
type PanelFooterRef = FlexBoxRef;
declare const PanelFooter: React.ForwardRefExoticComponent<PanelFooterProps & React.RefAttributes<HTMLDivElement>>;
declare class Panel extends Component<PanelProps> {
    static readonly displayName = "Panel";
    static Panel: React.ForwardRefExoticComponent<PanelProps & React.RefAttributes<HTMLDivElement>>;
    static Header: React.ForwardRefExoticComponent<PanelHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static SymbolHeader: React.ForwardRefExoticComponent<PanelSymbolHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static Body: React.ForwardRefExoticComponent<PanelBodyProps & React.RefAttributes<HTMLDivElement>>;
    static Footer: React.ForwardRefExoticComponent<PanelFooterProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface BannerPanelProps extends PanelProps {
    /** Controls padding */
    size?: ComponentSize;
    /** Icon to be displayed to the left of text */
    icon?: IconFont;
    /** Color of text, leave blank to have the text color computed for optimal contrast from the background */
    textColor?: InfluxColors | string;
    /** Hides the icon at smallest breakpoint */
    hideMobileIcon?: boolean;
}
type BannerPanelRef = HTMLDivElement;
declare const BannerPanel: React.ForwardRefExoticComponent<BannerPanelProps & React.RefAttributes<HTMLDivElement>>;
interface PopNavProps extends StandardFunctionProps {
    /** Height of bar and it's elements */
    size?: ComponentSize;
    /** Sets the alignment of the menu to the button */
    align?: Alignment;
    /** Controls initial visibility of the menu */
    visible?: boolean;
    /** Controls the color of the trigger button */
    buttonColor?: ComponentColor;
}
type PopNavRef = HTMLDivElement;
interface PopNavItemProps extends StandardFunctionProps {
    /** Controls highlighting of the menu item */
    active: boolean;
    /** Render prop for linked title text (suggested <a /> or <Link /> ) */
    titleLink: (className: string, testID?: string, style?: CSSProperties) => JSX.Element;
}
declare const PopNavItem: FunctionComponent<PopNavItemProps>;
declare class PopNav extends Component<PopNavProps> {
    static readonly displayName = "PopNav";
    static PopNav: React.ForwardRefExoticComponent<PopNavProps & React.RefAttributes<HTMLDivElement>>;
    static Item: React.FunctionComponent<PopNavItemProps>;
    render(): JSX.Element;
}
interface QuestionMarkTooltipProps extends StandardFunctionProps {
    /** Controls the size of the question mark circle */
    diameter?: number;
    /** Contents to display in tooltip */
    tooltipContents: JSX.Element | string;
    /** Coloration of tooltip and question mark circle */
    color?: ComponentColor;
    /** Useful for customizing the tooltip itself */
    tooltipStyle?: CSSProperties;
}
type QuestionMarkTooltipRef = HTMLSpanElement;
declare const QuestionMarkTooltip: React.ForwardRefExoticComponent<QuestionMarkTooltipProps & React.RefAttributes<HTMLSpanElement>>;
type PopoverDialogRef = HTMLDivElement;
interface PopoverProps extends StandardFunctionProps {
    /** Popover dialog color */
    color?: ComponentColor;
    /** Popover dialog contents */
    contents: (onHide?: () => void) => JSX.Element;
    /** Type of interaction to show the popover dialog */
    showEvent?: PopoverInteraction;
    /** Type of interaction to hide the popover dialog */
    hideEvent?: PopoverInteraction;
    /** Callback function fired when state changes to "show" */
    onShow?: () => void;
    /** Callback function fired when state changes to "hide" */
    onHide?: () => void;
    /** Pixel distance between trigger and popover dialog */
    distanceFromTrigger?: number;
    /** Size of caret (triangle) that points at the trigger */
    caretSize?: number;
    /** Where to position the popover relative to the trigger (assuming it fits there) */
    position?: PopoverPosition;
    /** Means of applying color to popover */
    appearance: Appearance;
    /** For external control of the popover state, overrides escape key behavior  */
    visible?: boolean;
    /** Disables the popover's show interaction */
    disabled?: boolean;
    /** Reference to trigger element */
    triggerRef: RefObject<any>;
    /** Adds reasonable styles to popover dialog contents so you do not have to */
    enableDefaultStyles?: boolean;
    /** Ensures the popover appears above all other portal elements */
    forceToTop?: boolean;
}
type PopoverRef = PopoverDialogRef;
interface ReflessPopoverProps extends Omit<PopoverProps, "triggerRef"> {
    /** Useful for correcting any layout disruptions */
    triggerStyle?: CSSProperties;
}
declare const ReflessPopover: FunctionComponent<ReflessPopoverProps>;
declare class Popover extends Component<PopoverProps> {
    static readonly displayName = "Popover";
    static Popover: React.ForwardRefExoticComponent<PopoverProps & React.RefAttributes<HTMLDivElement>>;
    static DismissButton: React.ForwardRefExoticComponent<DismissButtonProps & React.RefAttributes<HTMLButtonElement>>;
    render(): JSX.Element;
}
interface ProgressBarProps extends StandardFunctionProps {
    /** Controls the gradient color of the bar */
    barGradient?: Gradients;
    /** Controls the text color and bar if no gradient is provided */
    color?: InfluxColors | string;
    /** The current amount */
    value?: number;
    /** The total amount */
    max?: number;
    /** Controls the size of the bar & text */
    size?: ComponentSize;
    /** Descriptive text for what is being valueed */
    label?: string;
}
type ProgressBarRef = HTMLDivElement;
declare const ProgressBar: React.ForwardRefExoticComponent<ProgressBarProps & React.RefAttributes<HTMLDivElement>>;
type threshold = {
    floor: number;
    color?: InfluxColors | string;
    gradient?: Gradients;
};
interface ThresholdBarProps extends Omit<ProgressBarProps, "barGradient" | "color"> {
    /** The current amount */
    value?: number;
    /** The total amount */
    max?: number;
    /** Controls the size of the bar & text */
    size?: ComponentSize;
    /** Descriptive text for what is being valueed */
    label?: string;
    /** An array of thresholds and colors to be used at each */
    thresholds?: threshold[];
}
type ThresholdBarRef = HTMLDivElement;
declare const ThresholdBar: React.ForwardRefExoticComponent<ThresholdBarProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceCardProps extends Omit<FlexBoxProps, "stretchToFitWidth" | "stretchToFitHeight"> {
    /** Renders the card with disabled styles */
    disabled?: boolean;
    /** Renders the context menu component in its designated place */
    contextMenu?: JSX.Element;
    /** Controls the interaction style for the contextMenu */
    contextMenuInteraction?: "alwaysVisible" | "showOnHover";
    /** If true the card will highlight on mouse over */
    highlightOnHover?: boolean;
}
type ResourceCardRef = HTMLDivElement;
interface ResourceCardNameProps extends StandardFunctionProps {
    /** Text to display as name */
    name: string;
    /** Fires when the name is clicked */
    onClick?: (e: MouseEvent<HTMLAnchorElement>) => void;
    /** error message to be displayeed IF the name component has an error status */
    errorMessage?: string;
    /** Display error state or default state */
    status?: ComponentStatus.Default | ComponentStatus.Error;
}
type ResourceCardNameRef = HTMLDivElement;
declare const ResourceCardName: React.ForwardRefExoticComponent<ResourceCardNameProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceCardEditableNameProps extends StandardFunctionProps {
    /** Called when editing is finished, new name is passed  */
    onUpdate: (name: string) => void;
    /** Text to display as name */
    name: string;
    /** Fires when the name itself is clicked and not edited */
    onClick?: (e: MouseEvent<HTMLAnchorElement>) => void;
    /** Placeholder text to display in input during editing */
    placeholder?: string;
    /** Text to display when not editing and when no name is present */
    noNameString?: string;
    /** TestID for edit button sub-component */
    buttonTestID?: string;
    /** TestID for input sub-component */
    inputTestID?: string;
    /** Pass through to assign a ref to the Input present in edit mode */
    inputRef?: RefObject<InputRef>;
}
type ResourceCardEditableNameRef = HTMLDivElement;
declare const ResourceCardEditableName: React.ForwardRefExoticComponent<ResourceCardEditableNameProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceCardDescriptionProps extends StandardFunctionProps {
    /** Text to display in description */
    description: string;
}
type ResourceCardDescriptionRef = HTMLDivElement;
declare const ResourceCardDescription: React.ForwardRefExoticComponent<ResourceCardDescriptionProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceCardEditableDescriptionProps extends StandardFunctionProps {
    /** Called when user hits enter or blurs the input  */
    onUpdate: (description: string) => void;
    /** Text to display in description */
    description: string;
    /** Placeholder text to display in input during editing */
    placeholder?: string;
    /** Pass through to assign a ref to the Input present in edit mode */
    inputRef?: RefObject<InputRef>;
}
type ResourceCardEditableDescriptionRef = HTMLDivElement;
declare const ResourceCardEditableDescription: React.ForwardRefExoticComponent<ResourceCardEditableDescriptionProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceCardMetaProps extends Omit<FlexBoxProps, "stretchToFitWidth" | "stretchToFitHeight" | "margin"> {
}
type ResourceCardMetaRef = FlexBoxRef;
declare const ResourceCardMeta: React.ForwardRefExoticComponent<ResourceCardMetaProps & React.RefAttributes<HTMLDivElement>>;
declare class ResourceCard extends Component<ResourceCardProps> {
    static readonly displayName = "ResourceCard";
    static ResourceCard: React.ForwardRefExoticComponent<ResourceCardProps & React.RefAttributes<HTMLDivElement>>;
    static Name: React.ForwardRefExoticComponent<ResourceCardNameProps & React.RefAttributes<HTMLDivElement>>;
    static EditableName: React.ForwardRefExoticComponent<ResourceCardEditableNameProps & React.RefAttributes<HTMLDivElement>>;
    static Description: React.ForwardRefExoticComponent<ResourceCardDescriptionProps & React.RefAttributes<HTMLDivElement>>;
    static EditableDescription: React.ForwardRefExoticComponent<ResourceCardEditableDescriptionProps & React.RefAttributes<HTMLDivElement>>;
    static Meta: React.ForwardRefExoticComponent<ResourceCardMetaProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface ResourceListProps extends StandardFunctionProps {
}
type ResourceListRef = HTMLDivElement;
interface ResourceListHeaderProps extends StandardFunctionProps {
    /** Used for rendering a filter input above the list, opposite the sort headers */
    filterComponent?: JSX.Element;
}
type ResourceListHeaderRef = HTMLDivElement;
declare const ResourceListHeader: React.ForwardRefExoticComponent<ResourceListHeaderProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceListSorterProps extends StandardFunctionProps {
    /** Controls appearance of sort indicator (arrow) */
    sort: Sort;
    /** Unique identifier for use in managing sort state */
    sortKey: string;
    /** Name of attribute this element sorts on */
    name: string;
    /** Useful for triggering a change in sort state */
    onClick?: (nextSort: Sort, sortKey: string) => void;
}
type ResourceListSorterRef = HTMLDivElement;
declare const ResourceListSorter: React.ForwardRefExoticComponent<ResourceListSorterProps & React.RefAttributes<HTMLDivElement>>;
interface ResourceListBodyProps extends StandardFunctionProps {
    /** Element to show when no children are passed in, useful for implementing filtering */
    emptyState: JSX.Element;
}
type ResourceListBodyRef = HTMLDivElement;
declare const ResourceListBody: React.ForwardRefExoticComponent<ResourceListBodyProps & React.RefAttributes<HTMLDivElement>>;
declare class ResourceList extends Component<ResourceListProps> {
    static readonly displayName = "ResourceList";
    static ResourceList: React.ForwardRefExoticComponent<ResourceListProps & React.RefAttributes<HTMLDivElement>>;
    static Header: React.ForwardRefExoticComponent<ResourceListHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static Sorter: React.ForwardRefExoticComponent<ResourceListSorterProps & React.RefAttributes<HTMLDivElement>>;
    static Body: React.ForwardRefExoticComponent<ResourceListBodyProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
type RightClickMenuRef = HTMLUListElement;
interface RightClickProps extends StandardFunctionProps {
    /** RightClick menu color */
    color?: ComponentColor;
    /** Callback function fired when state changes to "show" */
    onShow?: () => void;
    /** Callback function fired when state changes to "hide" */
    onHide?: () => void;
    /** Prevents the right click menu from firing */
    disabled?: boolean;
    /** Reference to trigger element */
    triggerRef: RefObject<any>;
}
type RightClickRef = RightClickMenuRef;
interface RightClickMenuItemProps extends StandardFunctionProps {
    /** Click handler */
    onClick: (value?: any, e?: MouseEvent<HTMLLIElement>) => void;
    /** Disabled */
    disabled?: boolean;
    /** Optional return value */
    value?: any;
}
type RightClickMenuItemRef = HTMLLIElement;
declare const RightClickMenuItem: React.ForwardRefExoticComponent<RightClickMenuItemProps & React.RefAttributes<HTMLLIElement>>;
interface RightClickDividerProps extends StandardFunctionProps {
}
type RightClickDividerRef = HTMLLIElement;
declare const RightClickDivider: React.ForwardRefExoticComponent<RightClickDividerProps & React.RefAttributes<HTMLLIElement>>;
declare class RightClick extends Component<RightClickProps> {
    static readonly displayName = "RightClick";
    static RightClick: React.ForwardRefExoticComponent<RightClickProps & React.RefAttributes<HTMLUListElement>>;
    static MenuItem: React.ForwardRefExoticComponent<RightClickMenuItemProps & React.RefAttributes<HTMLLIElement>>;
    static Divider: React.ForwardRefExoticComponent<RightClickDividerProps & React.RefAttributes<HTMLLIElement>>;
    render(): JSX.Element;
}
interface SelectableCardProps extends StandardFunctionProps {
    /** Unique identifier for this card, is passed in to the hidden checkbox input */
    id: string;
    /** Text label */
    label: string;
    /** Useful for toggling selected state */
    onClick: (id?: string, e?: MouseEvent<SelectableCardRef>) => void;
    /** Useful for toggling selected state */
    onKeyDown?: (id?: string, e?: KeyboardEvent<SelectableCardRef>) => void;
    /** Controls font size of the card's label */
    fontSize?: ComponentSize;
    /** Controls the color of the selected border */
    color?: ComponentColor;
    /** Renders the card in selected state */
    selected?: boolean;
    /** Renders the card in disabled state */
    disabled?: boolean;
    /** Name of the form containing this card */
    formName?: string;
    /** Customize the icon that appears in selected state */
    icon?: IconFont;
    /** Customize the icon that appears in selected state */
    tabIndex?: number;
}
type SelectableCardRef = HTMLDivElement;
declare const SelectableCard: React.ForwardRefExoticComponent<SelectableCardProps & React.RefAttributes<HTMLDivElement>>;
interface SlideToggleProps extends StandardFunctionProps {
    /** Function to be called on slide toggle state change */
    onChange: () => void;
    /** Toggles slide toggle active state */
    active: boolean;
    /** Button size */
    size?: ComponentSize;
    /** Slide toggle color */
    color?: ComponentColor;
    /** Toggles disabled state */
    disabled?: boolean;
    /** Text to be displayed on hover tooltip */
    tooltipText?: string;
}
type SlideToggleRef = HTMLDivElement;
declare class SlideToggle extends Component<SlideToggleProps> {
    static readonly displayName = "SlideToggle";
    static SlideToggle: React.ForwardRefExoticComponent<SlideToggleProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface SpinnerContainerProps extends StandardFunctionProps {
    /** Loading state */
    loading: RemoteDataState;
    /** Spinner component */
    spinnerComponent: JSX.Element;
}
type SpinnerContainerRef = HTMLDivElement;
declare const SpinnerContainer: React.ForwardRefExoticComponent<SpinnerContainerProps & React.RefAttributes<HTMLDivElement>>;
interface SparkleSpinnerProps extends StandardFunctionProps {
    /** Size of spinner (square) */
    sizePixels?: number;
    /** State */
    loading?: RemoteDataState;
}
type SparkleSpinnerRef = HTMLDivElement;
declare const SparkleSpinner: React.ForwardRefExoticComponent<SparkleSpinnerProps & React.RefAttributes<HTMLDivElement>>;
interface TechnoSpinnerProps extends StandardFunctionProps {
    /** Diameter of spinner circle */
    diameterPixels?: number;
    /** Width of spinner stroke */
    strokeWidth?: ComponentSize;
}
type TechnoSpinnerRef = HTMLDivElement;
declare const TechnoSpinner: React.ForwardRefExoticComponent<TechnoSpinnerProps & React.RefAttributes<HTMLDivElement>>;
interface WaitingTextProps extends StandardFunctionProps {
    /** Text to be displayed */
    text: string;
}
type WaitingTextRef = HTMLDivElement;
declare const WaitingText: React.ForwardRefExoticComponent<WaitingTextProps & React.RefAttributes<HTMLDivElement>>;
interface SquareGridProps extends StandardFunctionProps {
    /** Approximate size of each card, must be in px, rem, or em */
    cardSize: string;
    /** Gap between cards */
    gutter?: ComponentSize;
}
type SquareGridRef = HTMLDivElement;
interface SquareGridCardProps extends StandardFunctionProps {
}
type SquareGridCardRef = HTMLDivElement;
declare const SquareGridCard: React.ForwardRefExoticComponent<SquareGridCardProps & React.RefAttributes<HTMLDivElement>>;
declare class SquareGrid extends Component<SquareGridProps> {
    static readonly displayName = "SquareGrid";
    static SquareGrid: React.ForwardRefExoticComponent<SquareGridProps & React.RefAttributes<HTMLDivElement>>;
    static Card: React.ForwardRefExoticComponent<SquareGridCardProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface TableProps extends StandardFunctionProps {
    /** Padding inside every cell in the table */
    cellPadding?: ComponentSize;
    /** Font size of table elements */
    fontSize?: ComponentSize;
    /** Controls the appearance of borders in the table */
    borders?: BorderType;
    /** Controls coloration pattern of rows, useful for improving legibility on dense tables */
    striped?: boolean;
    /** Highlights a row on hover, useful for improving legibility on dense tables */
    highlight?: boolean;
}
type TableRef = HTMLTableElement;
interface TableBodyProps extends StandardFunctionProps {
}
type TableBodyRef = HTMLTableSectionElement;
declare const TableBody: React.ForwardRefExoticComponent<TableBodyProps & React.RefAttributes<HTMLTableSectionElement>>;
interface TableCellProps extends StandardFunctionProps {
    /** How many columns this cell should take up */
    colSpan?: number;
    /** Horizontal alignment of contents */
    horizontalAlignment?: Alignment;
    /** Vertical alignment of contents */
    verticalAlignment?: VerticalAlignment;
}
type TableCellRef = HTMLTableDataCellElement;
declare const TableCell: React.ForwardRefExoticComponent<TableCellProps & React.RefAttributes<HTMLTableDataCellElement>>;
interface TableFooterProps extends StandardFunctionProps {
}
type TableFooterRef = HTMLTableSectionElement;
declare const TableFooter: React.ForwardRefExoticComponent<TableFooterProps & React.RefAttributes<HTMLTableSectionElement>>;
interface TableHeaderProps extends StandardFunctionProps {
}
type TableHeaderRef = HTMLTableSectionElement;
declare const TableHeader: React.ForwardRefExoticComponent<TableHeaderProps & React.RefAttributes<HTMLTableSectionElement>>;
interface TableHeaderCellProps extends StandardFunctionProps {
    /** How many columns this cell should take up */
    colSpan?: number;
    /** Horizontal alignment of contents */
    horizontalAlignment?: Alignment;
    /** Vertical alignment of contents */
    verticalAlignment?: VerticalAlignment;
}
type TableHeaderCellRef = HTMLTableHeaderCellElement;
declare const TableHeaderCell: React.ForwardRefExoticComponent<TableHeaderCellProps & React.RefAttributes<HTMLTableHeaderCellElement>>;
interface TableRowProps extends StandardFunctionProps {
    /** Controls coloration of the row, useful for showing a certain state */
    color?: ComponentColor;
}
type TableRowRef = HTMLTableRowElement;
declare const TableRow: React.ForwardRefExoticComponent<TableRowProps & React.RefAttributes<HTMLTableRowElement>>;
declare class Table extends Component<TableProps> {
    static readonly displayName = "Table";
    static Table: React.ForwardRefExoticComponent<TableProps & React.RefAttributes<HTMLTableElement>>;
    static Body: React.ForwardRefExoticComponent<TableBodyProps & React.RefAttributes<HTMLTableSectionElement>>;
    static Cell: React.ForwardRefExoticComponent<TableCellProps & React.RefAttributes<HTMLTableDataCellElement>>;
    static Footer: React.ForwardRefExoticComponent<TableFooterProps & React.RefAttributes<HTMLTableSectionElement>>;
    static Header: React.ForwardRefExoticComponent<TableHeaderProps & React.RefAttributes<HTMLTableSectionElement>>;
    static HeaderCell: React.ForwardRefExoticComponent<TableHeaderCellProps & React.RefAttributes<HTMLTableHeaderCellElement>>;
    static Row: React.ForwardRefExoticComponent<TableRowProps & React.RefAttributes<HTMLTableRowElement>>;
    render(): JSX.Element;
}
interface TabsProps extends StandardFunctionProps {
    /** Size of tabs */
    size?: ComponentSize;
    /** Alignment of tabs within container (large displays) */
    alignment?: Alignment;
    /** Layout axis of tabs */
    orientation?: Orientation;
    /** When the viewport is wider than this amount, render as tabs */
    dropdownBreakpoint?: Breakpoint | number;
    /** Label that only appears on small displays to indicate which tab is active when the component is collapsed  */
    dropdownLabel?: string;
    /** Alignment of tabs within container (small displays) */
    dropdownAlignment?: Alignment;
}
type TabsRef = HTMLElement;
interface TabProps extends StandardFunctionProps {
    /** Renders the tab highlighted */
    active: boolean;
    /** Unique identifier of tab */
    id: string;
    /** Text label of tab */
    text: string;
    /** Icon to appear left of the text label */
    icon?: JSX.Element;
    /** Function to call when tab is clicked, id of tab is passed in */
    onClick?: (id?: string) => void;
    /** If a function is passed in a dismiss button is rendered in the right of the tab */
    onDismiss?: (id?: string) => void;
    /** Optional link element. Will override onClick prop */
    linkElement?: RenderLinkElement;
}
type TabRef = HTMLDivElement;
declare const Tab: React.ForwardRefExoticComponent<TabProps & React.RefAttributes<HTMLDivElement>>;
interface TabContentsProps extends StandardFunctionProps {
}
type TabContentsRef = HTMLDivElement;
declare const TabContents: React.ForwardRefExoticComponent<TabContentsProps & React.RefAttributes<HTMLDivElement>>;
interface TabsContainerProps extends StandardFunctionProps {
    /** Should match the orientation prop of Tabs component */
    orientation: Orientation;
    /** Stretches TabsContainer to fit parent width */
    stretchToFitWidth?: boolean;
    /** Stretches TabsContainer to fit parent height */
    stretchToFitHeight?: boolean;
}
type TabsContainerRef = FlexBoxRef;
declare const TabsContainer: React.ForwardRefExoticComponent<TabsContainerProps & React.RefAttributes<HTMLDivElement>>;
declare class Tabs extends Component<TabsProps> {
    static readonly displayName = "Tabs";
    static Tabs: React.ForwardRefExoticComponent<TabsProps & React.RefAttributes<HTMLElement>>;
    static Tab: React.ForwardRefExoticComponent<TabProps & React.RefAttributes<HTMLDivElement>>;
    static TabContents: React.ForwardRefExoticComponent<TabContentsProps & React.RefAttributes<HTMLDivElement>>;
    static Container: React.ForwardRefExoticComponent<TabsContainerProps & React.RefAttributes<HTMLDivElement>>;
    render(): JSX.Element;
}
interface TextBlockProps extends StandardFunctionProps {
    /** Contents of text block */
    text: string;
    /** Sizing of text block, should be the same as the adjacent form elements */
    size?: ComponentSize;
    /** Background color of text block */
    backgroundColor?: InfluxColors | string;
    /** Color of text, leave blank to have the text color computed for optimal contrast from the background */
    textColor?: InfluxColors | string;
    /** Use monospace font instead of default */
    monospace?: boolean;
}
type TextBlockRef = HTMLDivElement;
declare const TextBlock: React.ForwardRefExoticComponent<TextBlockProps & React.RefAttributes<HTMLDivElement>>;
interface GradientBoxProps extends StandardFunctionProps {
    /** Controls the border gradient color */
    borderGradient?: Gradients;
    /** Controls the border gradient color */
    borderColor?: InfluxColors | string;
}
type GradientBoxRef = HTMLDivElement;
declare const GradientBox: React.ForwardRefExoticComponent<GradientBoxProps & React.RefAttributes<HTMLDivElement>>;
interface TreeNavProps extends StandardFunctionProps {
    /** Controls the size of the navigation menu */
    expanded: boolean;
    /** Callback for handling toggle clicks */
    onToggleClick?: () => void;
    /** Element to appear at the top of the nav menu */
    headerElement?: JSX.Element;
    /** Banner to appear in expanded menu */
    bannerElement?: JSX.Element;
    /** User widget to appear below the header element */
    userElement?: JSX.Element;
    /** Controls how the Banner element renders when in collapsed state */
    hideBannerWhenCollapsed?: boolean;
}
type TreeNavRef = HTMLElement;
interface TreeNavHeaderProps extends Omit<StandardFunctionProps, "id"> {
    /** Unique identifier for nav item */
    id: string;
    /** Icon or Image to appear in the square */
    icon: JSX.Element;
    /** Label to appear to the right of the icon, only visible when expanded */
    label: JSX.Element;
    /** Coloration of the Header */
    color?: ComponentColor;
    /** Controls state of item */
    active?: boolean;
    /** Click behavior */
    onClick?: (id: string) => void;
    /** Optional link element. Will override onClick prop */
    linkElement?: RenderLinkElement;
}
type TreeNavHeaderRef = HTMLDivElement;
declare const TreeNavHeader: React.ForwardRefExoticComponent<TreeNavHeaderProps & React.RefAttributes<HTMLDivElement>>;
interface TreeNavUserProps extends StandardFunctionProps {
    /** Username, only visible when expanded */
    username: string;
    /** User's currently active team */
    team?: string;
}
type TreeNavUserRef = HTMLDivElement;
declare const TreeNavUser: React.ForwardRefExoticComponent<TreeNavUserProps & React.RefAttributes<HTMLDivElement>>;
interface TreeNavUserItemProps extends Omit<StandardFunctionProps, "id"> {
    /** Unique identifier for user item */
    id: string;
    /** Controls highlighting of the user item */
    active?: boolean;
    /** Label for item */
    label: string;
    /** Click behavior */
    onClick?: (id: string) => void;
    /** Optional link element. Will override onClick prop */
    linkElement?: RenderLinkElement;
}
declare const TreeNavUserItem: FunctionComponent<TreeNavUserItemProps>;
interface TreeNavItemProps extends Omit<StandardFunctionProps, "id"> {
    /** Unique identifier for nav item */
    id: string;
    /** Icon or Image to appear in the square */
    icon: JSX.Element;
    /** Label to appear to the right of the icon, only visible when expanded */
    label: string;
    /** Optional label displayed when the TreeNav is collapsed */
    shortLabel?: string;
    /** Click behavior */
    onClick?: (id: string) => void;
    /** Controls state of item */
    active?: boolean;
    /** Optional link element. Will override onClick prop */
    linkElement?: RenderLinkElement;
}
type TreeNavItemRef = HTMLDivElement;
declare const TreeNavItem: React.ForwardRefExoticComponent<TreeNavItemProps & React.RefAttributes<HTMLDivElement>>;
interface TreeNavSubItemProps extends Omit<StandardFunctionProps, "id"> {
    /** Unique identifier for nav sub item */
    id: string;
    /** Controls highlighting of the menu item */
    active?: boolean;
    /** Label for item */
    label: string;
    /** Click behavior */
    onClick?: (id: string) => void;
    /** Optional link element. Will override onClick prop */
    linkElement?: RenderLinkElement;
}
declare const TreeNavSubItem: FunctionComponent<TreeNavSubItemProps>;
declare class TreeNav extends Component<TreeNavProps> {
    static readonly displayName = "TreeNav";
    static TreeNav: React.ForwardRefExoticComponent<TreeNavProps & React.RefAttributes<HTMLElement>>;
    static Header: React.ForwardRefExoticComponent<TreeNavHeaderProps & React.RefAttributes<HTMLDivElement>>;
    static User: React.ForwardRefExoticComponent<TreeNavUserProps & React.RefAttributes<HTMLDivElement>>;
    static UserItem: React.FunctionComponent<TreeNavUserItemProps>;
    static Item: React.ForwardRefExoticComponent<TreeNavItemProps & React.RefAttributes<HTMLDivElement>>;
    static SubMenu: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLDivElement>>;
    static SubItem: React.FunctionComponent<TreeNavSubItemProps>;
    render(): JSX.Element;
}
type TreeNavSubMenuProps = StandardFunctionProps;
type TreeNavSubMenuRef = HTMLDivElement;
declare const TreeNavSubMenu: React.ForwardRefExoticComponent<StandardFunctionProps & React.RefAttributes<HTMLDivElement>>;
interface HeadingProps extends StandardFunctionProps {
    weight?: FontWeight;
    /** Use monospace font instead of default */
    type?: Typeface;
    /** Controls appearance of border below heading */
    underline?: boolean;
    /** Element to use for heading */
    element: HeadingElement;
    /** Visual only - will match the element prop if not specified */
    appearance?: HeadingElement;
    /** Controls whether the text can be selected */
    selectable?: boolean;
    /** Function to be called on button click */
    onClick?: (e?: MouseEvent<HTMLButtonElement>) => void;
    /** Alternate text */
    alt?: string;
}
type HeadingRef = HTMLHeadingElement;
declare const Heading: React.ForwardRefExoticComponent<HeadingProps & React.RefAttributes<HTMLHeadingElement>>;
declare const DROPDOWN_DIVIDER_SHORTCODE = "---";
declare const GRID_BREAKPOINT_SM = 750;
declare const GRID_BREAKPOINT_MD = 1080;
declare const GRID_BREAKPOINT_LG = 1500;
type Test = ((...args: any[]) => boolean) | undefined;
interface RBACProps<P> {
    /** List of permissions */
    permissions?: P[] | undefined;
    /** The permission required to perform an action */
    perform?: P;
    /** An arbitrary callback if returns true the "yes" prop will render */
    test?: Test;
    /** If the "perform" prop is in the list of permissions yes will render */
    yes: () => any;
    /** If the "perform" prop is NOT in the list of permissions no will render */
    no: () => any;
}
declare function RBAC<P>({ permissions, perform, test, yes, no }: RBACProps<P>): JSX.Element;
declare namespace RBAC$0 {
    var displayName: string;
}
declare const usePortal: () => {
    addElementToPortal: (element: React.ReactNode, forceToTop?: boolean | undefined) => React.ReactPortal;
    addNotificationToPortal: (element: React.ReactNode, x: Alignment, y: VerticalAlignment) => React.ReactPortal;
    addEventListenerToPortal: (eventType: string, func: any) => void;
    removeEventListenerFromPortal: (eventType: string, func: any) => void;
};
export { AlertRef, Alert, AppHeader, AppHeaderProps, AppHeaderRef, AppHeaderLogoProps, AppHeaderLogoRef, AppHeaderLogo, AppWrapperType, AppWrapperProps, AppWrapperRef, AppWrapper, ButtonBaseProps, ButtonBaseRef, ButtonBase, ButtonProps, ButtonRef, Button, ButtonGroupProps, ButtonGroupRef, ButtonGroup, ConfirmationButtonProps, ConfirmationButton, CTAButtonProps, CTAButtonRef, CTAButton, DismissButtonProps, DismissButtonRef, DismissButton, SquareButtonProps, SquareButtonRef, SquareButton, CTALinkButtonProps, CTALinkButtonRef, CTALinkButton, LinkButtonProps, LinkButtonRef, LinkButton, ClickOutside, ColorPickerRef, ColorPicker, ColorPickerSwatchRef, ColorPickerSwatch, FusionScrollEvent, FusionScrollHandler, DapperScrollbars, DatePickerRef, DatePicker, DateRangePickerProps, DateRangePickerRef, DateRangePicker, DraggableResizer, DraggableResizerProps, DraggableResizerPanelProps, DraggableResizerPanelRef, DraggableResizerPanel, MultiSelectDropdownProps, MultiSelectDropdownRef, MultiSelectDropdown, SelectDropdownProps, SelectDropdownRef, SelectDropdown, Dropdown, DropdownProps, DropdownRef, MenuStatus, DropdownMenuProps, DropdownMenuRef, DropdownMenuContentsRef, DropdownMenu, DropdownButtonProps, DropdownButtonRef, DropdownButton, DropdownItemProps, DropdownItemRef, DropdownItem, DropdownItemEmptyProps, DropdownItemEmptyRef, DropdownItemEmpty, DropdownLinkItemProps, DropdownLinkItemRef, DropdownLinkItem, DropdownDividerProps, DropdownDividerRef, DropdownDivider, EmptyState, EmptyStateProps, EmptyStateRef, EmptyStateTextRef, EmptyStateText, EmptyStateSubTextRef, EmptyStateSubText, FlexBox, FlexBoxProps, FlexBoxRef, FlexBoxChildProps, FlexBoxChildRef, FlexBoxChild, FunnelPage, FunnelPageProps, FunnelPageRef, FunnelPageFooterProps, FunnelPageFooterRef, FunnelPageFooter, FunnelPageFooterSectionProps, FunnelPageFooterSectionRef, FunnelPageFooterSection, Form, FormProps, FormBoxProps, FormBoxRef, FormBox, FormDividerProps, FormDividerRef, FormDivider, FormElementProps, FormElementRef, FormElement, FormElementErrorProps, FormElementErrorRef, FormElementError, FormFooterProps, FormFooterRef, FormFooter, FormHelpTextProps, FormHelpTextRef, FormHelpText, FormLabelProps, FormLabelRef, FormLabel, FormValidationElementProps, FormValidationElementRef, FormValidationElement, Grid, GridProps, GridRef, GridColumnProps, GridColumnRef, GridColumn, GridRowProps, GridRowRef, GridRow, IconProps, IconRef, Icon, BulletProps, BulletRef, Bullet, IndexList, IndexListProps, IndexListRef, IndexListBodyProps, IndexListBodyRef, IndexListBody, IndexListHeaderProps, IndexListHeaderRef, IndexListHeader, IndexListHeaderCellProps, IndexListHeaderCellRef, IndexListHeaderCell, IndexListRowProps, IndexListRowRef, IndexListRow, IndexListRowCellProps, IndexListRowCellRef, IndexListRowCell, InputProps, InputRef, InputContainerRef, Input, InputLabelProps, InputLabelRef, InputLabel, TextAreaProps, TextAreaRef, TextAreaContainerRef, TextArea, ToggleProps, ToggleRef, ToggleContainerRef, Toggle, AutoInputProps, AutoInputRef, AutoInput, RangeSliderProps, RangeSliderRef, RangeSlider, VisibilityInputProps, VisibilityInputRef, VisibilityInput, TimeInputRef, TimeInputProps, TimeInput, LabelProps, LabelRef, Label, NavMenu, NavMenuProps, NavMenuRef, NavMenuItemProps, NavMenuItemRef, NavMenuItem, NavMenuSubItemProps, NavMenuSubItem, Notification, NotificationProps, NotificationRef, NotificationDialogProps, NotificationDialogRef, NotificationDialog, Overlay, OverlayProps, OverlayContainerProps, OverlayContainerRef, OverlayContainer, OverlayHeaderProps, OverlayHeaderRef, OverlayHeader, OverlayMaskProps, OverlayMaskRef, OverlayMask, OverlayBodyProps, OverlayBodyRef, OverlayBody, OverlayFooterProps, OverlayFooterRef, OverlayFooter, List, ListProps, ListRef, ListItemSharedProps, ListItemContextProps, ListItemProps, ListItemRef$0 as ListItemRef, ListItemContext, ListItem, ListEmptyStateProps, ListEmptyStateRef, ListEmptyState, ListDividerProps, ListDividerRef, ListDivider, ListIndicatorType, ListIndicatorProps, ListIndicator, ListIconProps, ListIcon, InfluxDataLogoProps, InfluxDataLogoRef, InfluxDataLogo, InfluxDBCloudLogoProps, InfluxDBCloudLogoRef, InfluxDBCloudLogo, Page, PageProps, PageRef, PageHeaderProps, PageHeaderRef, PageHeader, PageTitleProps, PageTitleRef, PageTitle, PageControlBarProps, PageControlBarRef, PageControlBar, PageControlBarLeftProps, PageControlBarLeftRef, PageControlBarLeft, PageControlBarCenterProps, PageControlBarCenterRef, PageControlBarCenter, PageControlBarRightProps, PageControlBarRightRef, PageControlBarRight, PageContentsProps, PageContentsRef, PageContents, PaginationNav, Pagination, PaginationNavRef, PaginationItemProps, PaginationItemRef, PaginationItem, PaginationTruncationItemProps, PaginationTruncationItemRef, PaginationTruncationItem, PaginationDirectionItemProps, PaginationDirectionItemRef, PaginationDirectionItem, Panel, PanelProps, PanelRef, PanelHeaderProps, PanelHeaderRef, PanelHeader, PanelSymbolHeaderProps, PanelSymbolHeaderRef, PanelSymbolHeader, PanelBodyProps, PanelBodyRef, PanelBody, PanelFooterProps, PanelFooterRef, PanelFooter, BannerPanelProps, BannerPanelRef, BannerPanel, PopNav, PopNavProps, PopNavRef, PopNavItemProps, PopNavItem, QuestionMarkTooltipProps, QuestionMarkTooltipRef, QuestionMarkTooltip, ReflessPopover, Popover, PopoverRef, ProgressBarProps, ProgressBarRef, ProgressBar, threshold, ThresholdBarProps, ThresholdBarRef, ThresholdBar, SelectGroup, SelectGroupProps, SelectGroupRef, SelectGroupOptionProps, SelectGroupOptionRef, SelectGroupOptionContainerRef, SelectGroupOption, ResourceCard, ResourceCardProps, ResourceCardRef, ResourceCardNameProps, ResourceCardNameRef, ResourceCardName, ResourceCardEditableNameProps, ResourceCardEditableNameRef, ResourceCardEditableName, ResourceCardDescriptionProps, ResourceCardDescriptionRef, ResourceCardDescription, ResourceCardEditableDescriptionProps, ResourceCardEditableDescriptionRef, ResourceCardEditableDescription, ResourceCardMetaProps, ResourceCardMetaRef, ResourceCardMeta, ResourceList, ResourceListProps, ResourceListRef, ResourceListHeaderProps, ResourceListHeaderRef, ResourceListHeader, ResourceListSorterProps, ResourceListSorterRef, ResourceListSorter, ResourceListBodyProps, ResourceListBodyRef, ResourceListBody, RightClick, RightClickProps, RightClickRef, RightClickMenuItemProps, RightClickMenuItemRef, RightClickMenuItem, RightClickDividerProps, RightClickDividerRef, RightClickDivider, SelectableCardProps, SelectableCardRef, SelectableCard, SlideToggle, SlideToggleProps, SlideToggleRef, SpinnerContainerProps, SpinnerContainerRef, SpinnerContainer, SparkleSpinnerProps, SparkleSpinnerRef, SparkleSpinner, TechnoSpinnerProps, TechnoSpinnerRef, TechnoSpinner, WaitingTextProps, WaitingTextRef, WaitingText, SquareGrid, SquareGridProps, SquareGridRef, SquareGridCardProps, SquareGridCardRef, SquareGridCard, Table, TableProps, TableRef, TableBodyProps, TableBodyRef, TableBody, TableCellProps, TableCellRef, TableCell, TableFooterProps, TableFooterRef, TableFooter, TableHeaderProps, TableHeaderRef, TableHeader, TableHeaderCellProps, TableHeaderCellRef, TableHeaderCell, TableRowProps, TableRowRef, TableRow, Tabs, TabsProps, TabsRef, TabProps, TabRef, Tab, TabContentsProps, TabContentsRef, TabContents, TabsContainerProps, TabsContainerRef, TabsContainer, TextBlockProps, TextBlockRef, TextBlock, GradientBoxProps, GradientBoxRef, GradientBox, TreeNav, TreeNavProps, TreeNavRef, TreeNavHeaderProps, TreeNavHeaderRef, TreeNavHeader, TreeNavUserProps, TreeNavUserRef, TreeNavUser, TreeNavUserItemProps, TreeNavUserItem, TreeNavItemProps, TreeNavItemRef, TreeNavItem, TreeNavSubMenuProps, TreeNavSubMenuRef, TreeNavSubMenu, TreeNavSubItemProps, TreeNavSubItem, HeadingProps, HeadingRef, Heading, Omit, StandardFunctionProps, ValidationFunction, RenderLinkElement, ComponentColor, ComponentSize, ComponentStatus, ComponentOrientation, Color, Gradient, Gradients, DropdownMenuTheme, DropdownMenuScrollbarColors, DropdownItemType, Direction, ButtonShape, ButtonType, InfluxColors, IconFont, Columns, Sort, Alignment, VerticalAlignment, JustifyContent, AlignItems, FlexDirection, RemoteDataState, AutoComplete, Orientation, BorderType, TimeRange, InputType, InputToggleType, AutoInputMode, PopoverInteraction, PopoverPosition, Appearance, EncType, Method, Wrap, Coordinates, LinkTarget, LinkRel, Typeface, HeadingElement, FontWeight, Breakpoint, DROPDOWN_DIVIDER_SHORTCODE, GRID_BREAKPOINT_SM, GRID_BREAKPOINT_MD, GRID_BREAKPOINT_LG, RBAC, usePortal };
